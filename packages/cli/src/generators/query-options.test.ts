import { readFileSync } from "node:fs";
import { resolve } from "node:path";

import { buildSchema } from "graphql";
import { describe, expect, it } from "vitest";

import { loadDocuments } from "../core/documents";
import { generateGraphQLOperations } from "./query-options";

const fixturesDir = resolve(__dirname, "../test/fixtures/graphql");

// Load schemas for tests
const schemaSDL = readFileSync(`${fixturesDir}/schema.graphql`, "utf-8");
const schema = buildSchema(schemaSDL);

const relaySchemaSDL = readFileSync(
  `${fixturesDir}/relay-schema.graphql`,
  "utf-8",
);
const relaySchema = buildSchema(relaySchemaSDL);

describe("generateGraphQLOperations", () => {
  it("generates operations file with eslint-disable comment", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain("/* eslint-disable */");
  });

  it("generates operations file with auto-generated comment", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain("auto-generated by tangrams");
  });

  it("imports queryOptions and mutationOptions from @tanstack/react-query", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain(
      'import { mutationOptions, queryOptions } from "@tanstack/react-query"',
    );
  });

  it("imports functions from the specified functions path", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain('from "../functions"');
  });

  it("imports types from the specified types path", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./custom-types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain('} from "./custom-types"');
  });

  it("generates queryOptions for query operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain("export const getUserQueryOptions");
    expect(result.content).toContain("export const listUsersQueryOptions");
  });

  it("generates mutation options for mutation operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain("export const createUserMutationOptions");
    expect(result.content).toContain("export const updateUserMutationOptions");
    expect(result.content).toContain("export const deleteUserMutationOptions");
  });

  it("includes queryKey for query operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain('queryKey: ["test", "GetUser"');
    expect(result.content).toContain('queryKey: ["test", "ListUsers"');
  });

  it("includes mutationKey for mutation operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain('mutationKey: ["test", "CreateUser"]');
    expect(result.content).toContain('mutationKey: ["test", "UpdateUser"]');
  });

  it("handles operations with required variables", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    // GetUser has required $id variable
    expect(result.content).toContain(
      "getUserQueryOptions = (variables: GetUserQueryVariables)",
    );
  });

  it("handles operations with optional variables", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    // ListUsers has all optional variables
    expect(result.content).toContain(
      "listUsersQueryOptions = (variables?: ListUsersQueryVariables)",
    );
  });

  it("only imports queryOptions when there are no mutations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/query-only.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain(
      'import { queryOptions } from "@tanstack/react-query"',
    );
    expect(result.content).not.toContain("mutationOptions");
  });

  it("only imports mutationOptions when there are no queries", async () => {
    const documents = await loadDocuments(
      `${fixturesDir}/mutation-only.graphql`,
    );
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toContain(
      'import { mutationOptions } from "@tanstack/react-query"',
    );
    expect(result.content).not.toContain("queryOptions");
  });

  it("calls imported function in queryFn", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    // Should import and call the function from functions.ts
    expect(result.content).toContain("queryFn: () => getUser(variables)");
  });

  it("calls imported function in mutationFn", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    // Should import and call the function from functions.ts
    expect(result.content).toContain(
      "mutationFn: (variables: CreateUserMutationVariables) => createUser(variables)",
    );
  });

  it("matches snapshot for user operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toMatchSnapshot();
  });

  it("matches snapshot for query-only operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/query-only.graphql`);
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toMatchSnapshot();
  });

  it("matches snapshot for mutation-only operations", async () => {
    const documents = await loadDocuments(
      `${fixturesDir}/mutation-only.graphql`,
    );
    const result = generateGraphQLOperations({
      documents,
      typesImportPath: "./types",
      functionsImportPath: "../functions",
      sourceName: "test",
      schema,
    });

    expect(result.content).toMatchSnapshot();
  });

  describe("schema-driven infinite query detection", () => {
    it("detects relay pagination from schema field args, not variable names", async () => {
      const documents = await loadDocuments(
        `${fixturesDir}/relay-operations.graphql`,
      );
      const result = generateGraphQLOperations({
        documents,
        typesImportPath: "./types",
        functionsImportPath: "../functions",
        sourceName: "test",
        schema: relaySchema,
      });

      // ListPosts uses $cursor and $pageSize but schema has after/first
      // Should still detect and generate infiniteQueryOptions
      expect(result.content).toContain("listPostsInfiniteQueryOptions");
      expect(result.content).toContain("infiniteQueryOptions");
    });

    it("maps schema arg to document variable for pageParam", async () => {
      const documents = await loadDocuments(
        `${fixturesDir}/relay-operations.graphql`,
      );
      const result = generateGraphQLOperations({
        documents,
        typesImportPath: "./types",
        functionsImportPath: "../functions",
        sourceName: "test",
        schema: relaySchema,
      });

      // The pageParam should use the variable name ($cursor), not the schema arg name (after)
      expect(result.content).toContain("cursor: pageParam");
    });

    it("generates correct getNextPageParam for relay connections", async () => {
      const documents = await loadDocuments(
        `${fixturesDir}/relay-operations.graphql`,
      );
      const result = generateGraphQLOperations({
        documents,
        typesImportPath: "./types",
        functionsImportPath: "../functions",
        sourceName: "test",
        schema: relaySchema,
      });

      // Should have proper relay-style getNextPageParam
      expect(result.content).toContain("posts?.pageInfo?.hasNextPage");
      expect(result.content).toContain("posts?.pageInfo?.endCursor");
    });

    it("uses alias in response path when field is aliased", async () => {
      const documents = await loadDocuments(
        `${fixturesDir}/relay-operations.graphql`,
      );
      const result = generateGraphQLOperations({
        documents,
        typesImportPath: "./types",
        functionsImportPath: "../functions",
        sourceName: "test",
        schema: relaySchema,
      });

      // ListPostsWithAlias uses `myPosts: posts(...)` so path should use myPosts
      expect(result.content).toContain("myPosts?.pageInfo?.hasNextPage");
      expect(result.content).toContain("myPosts?.pageInfo?.endCursor");
    });

    it("does not generate infiniteQueryOptions for non-paginated queries", async () => {
      const documents = await loadDocuments(
        `${fixturesDir}/relay-operations.graphql`,
      );
      const result = generateGraphQLOperations({
        documents,
        typesImportPath: "./types",
        functionsImportPath: "../functions",
        sourceName: "test",
        schema: relaySchema,
      });

      // GetPost is not paginated, should not have infinite query options
      expect(result.content).not.toContain("getPostInfiniteQueryOptions");
      // But should still have regular queryOptions
      expect(result.content).toContain("getPostQueryOptions");
    });

    it("matches snapshot for relay operations", async () => {
      const documents = await loadDocuments(
        `${fixturesDir}/relay-operations.graphql`,
      );
      const result = generateGraphQLOperations({
        documents,
        typesImportPath: "./types",
        functionsImportPath: "../functions",
        sourceName: "test",
        schema: relaySchema,
      });

      expect(result.content).toMatchSnapshot();
    });
  });
});
