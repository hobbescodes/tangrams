import { describe, expect, it } from "vitest";

import {
  createDefaultGenContext,
  extractSchemaDefinitions,
  generateDefaultValue,
  generateDefaultValuesCode,
} from "./defaults";

describe("extractSchemaDefinitions", () => {
  it("extracts single-line schema definitions", () => {
    const content = `export const fooSchema = z.string()
export const barSchema = z.number()`;

    const result = extractSchemaDefinitions(content);
    expect(result).toHaveLength(2);
    expect(result[0]).toBe("export const fooSchema = z.string()");
    expect(result[1]).toBe("export const barSchema = z.number()");
  });

  it("extracts multi-line object schema definitions", () => {
    const content = `export const userSchema = z.object({
  name: z.string(),
  age: z.number()
})
export const petSchema = z.string()`;

    const result = extractSchemaDefinitions(content);
    expect(result).toHaveLength(2);
    expect(result[0]).toBe(`export const userSchema = z.object({
  name: z.string(),
  age: z.number()
})`);
    expect(result[1]).toBe("export const petSchema = z.string()");
  });

  it("extracts schema aliases (references)", () => {
    const content = `export const createUserInputSchema = z.object({
  name: z.string()
})
export const createUserRequestSchema = createUserInputSchema`;

    const result = extractSchemaDefinitions(content);
    expect(result).toHaveLength(2);
    expect(result[0]).toContain("createUserInputSchema = z.object");
    expect(result[1]).toBe(
      "export const createUserRequestSchema = createUserInputSchema",
    );
  });

  it("handles nested brackets correctly", () => {
    const content = `export const complexSchema = z.object({
  tags: z.array(z.object({
    name: z.string(),
    value: z.number()
  })),
  status: z.enum(["active", "pending"])
})`;

    const result = extractSchemaDefinitions(content);
    expect(result).toHaveLength(1);
    expect(result[0]).toContain("complexSchema");
    expect(result[0]).toContain('z.enum(["active", "pending"])');
  });

  it("handles real-world generated schema content", () => {
    const content = `/* eslint-disable */
/* This file is auto-generated by tangrams. Do not edit. */

import * as z from "zod"

// Zod Schemas
export const petCategorySchema = z.enum(["dog", "cat", "bird"])
export const petStatusSchema = z.enum(["available", "pending", "sold"])
export const petSchema = z.object({
  id: z.string(),
  name: z.string(),
  category: petCategorySchema,
  status: petStatusSchema
})
export const createPetInputSchema = z.object({
  name: z.string(),
  category: petCategorySchema,
  status: petStatusSchema
})
export const createPetRequestSchema = createPetInputSchema`;

    const result = extractSchemaDefinitions(content);
    expect(result).toHaveLength(5);

    // Should have complete definitions
    const petCategoryDef = result.find((d) => d.includes("petCategorySchema"));
    expect(petCategoryDef).toBe(
      'export const petCategorySchema = z.enum(["dog", "cat", "bird"])',
    );

    const createPetInputDef = result.find((d) =>
      d.includes("createPetInputSchema = z.object"),
    );
    expect(createPetInputDef).toContain("name: z.string()");
    expect(createPetInputDef).toContain("category: petCategorySchema");

    const createPetRequestDef = result.find((d) =>
      d.includes("createPetRequestSchema"),
    );
    expect(createPetRequestDef).toBe(
      "export const createPetRequestSchema = createPetInputSchema",
    );
  });

  it("ignores non-schema exports and comments", () => {
    const content = `// This is a comment
export const fooSchema = z.string()
export type Foo = z.infer<typeof fooSchema>
export const barSchema = z.number()`;

    const result = extractSchemaDefinitions(content);
    expect(result).toHaveLength(2);
    expect(result.every((d) => d.includes("Schema ="))).toBe(true);
  });
});

describe("extractSchemaDefinitions + createDefaultGenContext integration", () => {
  it("resolves references through aliases to multi-line object schemas", () => {
    const content = `export const createPetInputSchema = z.object({
  name: z.string(),
  category: z.enum(["dog", "cat"]),
  status: z.enum(["available", "pending"])
})
export const createPetRequestSchema = createPetInputSchema`;

    const schemas = extractSchemaDefinitions(content);
    const ctx = createDefaultGenContext(schemas);

    // Should be able to resolve the reference
    const result = generateDefaultValue("createPetInputSchema", ctx);
    expect(result).toEqual({
      name: "",
      category: "dog",
      status: "available",
    });

    // Should also resolve through the alias
    const aliasResult = generateDefaultValue("createPetRequestSchema", ctx);
    expect(aliasResult).toEqual({
      name: "",
      category: "dog",
      status: "available",
    });
  });

  it("resolves nested schema references", () => {
    const content = `export const petCategorySchema = z.enum(["dog", "cat", "bird"])
export const petStatusSchema = z.enum(["available", "pending", "sold"])
export const createPetInputSchema = z.object({
  name: z.string(),
  category: petCategorySchema,
  status: petStatusSchema
})`;

    const schemas = extractSchemaDefinitions(content);
    const ctx = createDefaultGenContext(schemas);

    const result = generateDefaultValue("createPetInputSchema", ctx);
    expect(result).toEqual({
      name: "",
      category: "dog",
      status: "available",
    });
  });
});

describe("Default Value Generator", () => {
  describe("generateDefaultValue", () => {
    it("generates empty string for z.string()", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue("z.string()", ctx);
      expect(result).toBe("");
    });

    it("generates 0 for z.number()", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue("z.number()", ctx);
      expect(result).toBe(0);
    });

    it("generates 0 for z.number().int()", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue("z.number().int()", ctx);
      expect(result).toBe(0);
    });

    it("generates false for z.boolean()", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue("z.boolean()", ctx);
      expect(result).toBe(false);
    });

    it("generates empty array for z.array()", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue("z.array(z.string())", ctx);
      expect(result).toEqual([]);
    });

    it("generates null for nullable types", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue("z.string().nullable()", ctx);
      expect(result).toBe(null);
    });

    it("generates undefined for optional types", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue("z.string().optional()", ctx);
      expect(result).toBe(undefined);
    });

    it("generates first value for enums", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue(
        'z.enum(["active", "inactive"])',
        ctx,
      );
      expect(result).toBe("active");
    });

    it("generates object with default values for z.object()", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue(
        `z.object({
  name: z.string(),
  age: z.number()
})`,
        ctx,
      );
      expect(result).toEqual({ name: "", age: 0 });
    });

    it("excludes optional properties from object defaults", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValue(
        `z.object({
  name: z.string(),
  nickname: z.string().optional()
})`,
        ctx,
      );
      expect(result).toEqual({ name: "" });
    });

    it("resolves schema references", () => {
      const ctx = createDefaultGenContext([
        "export const userSchema = z.object({ name: z.string() })",
      ]);
      const result = generateDefaultValue("userSchema", ctx);
      expect(result).toEqual({ name: "" });
    });

    it("handles string format variants", () => {
      const ctx = createDefaultGenContext([]);

      expect(generateDefaultValue("z.email()", ctx)).toBe("");
      expect(generateDefaultValue("z.url()", ctx)).toBe("");
      expect(generateDefaultValue("z.uuid()", ctx)).toBe("");
      expect(generateDefaultValue("z.iso.datetime()", ctx)).toBe("");
      expect(generateDefaultValue("z.iso.date()", ctx)).toBe("");
    });
  });

  describe("generateDefaultValuesCode", () => {
    it("generates code for simple types", () => {
      const ctx = createDefaultGenContext([]);
      expect(generateDefaultValuesCode("z.string()", ctx)).toBe('""');
      expect(generateDefaultValuesCode("z.number()", ctx)).toBe("0");
      expect(generateDefaultValuesCode("z.boolean()", ctx)).toBe("false");
    });

    it("generates code for nullable types", () => {
      const ctx = createDefaultGenContext([]);
      expect(generateDefaultValuesCode("z.string().nullable()", ctx)).toBe(
        "null",
      );
    });

    it("generates code for objects", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValuesCode(
        `z.object({
  name: z.string(),
  age: z.number()
})`,
        ctx,
        "",
      );
      expect(result).toContain("name:");
      expect(result).toContain("age:");
    });

    it("generates code for enums with first value", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValuesCode(
        'z.enum(["active", "pending", "done"])',
        ctx,
      );
      expect(result).toBe('"active"');
    });

    it("handles nested objects", () => {
      const ctx = createDefaultGenContext([]);
      const result = generateDefaultValuesCode(
        `z.object({
  user: z.object({
    name: z.string()
  })
})`,
        ctx,
      );
      expect(result).toContain("user:");
      expect(result).toContain("name:");
    });
  });
});
