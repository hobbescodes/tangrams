/**
 * Shared Zod schema generation utilities
 * Used by both OpenAPI and GraphQL adapters to generate Zod schemas
 */

/**
 * A schema entry with its dependencies for topological sorting
 */
export interface SchemaEntry {
  name: string;
  zodType: string;
  dependencies: Set<string>;
}

/**
 * Context for Zod schema generation
 * Tracks generated schemas to avoid duplicates and handle dependencies
 */
export interface ZodGenContext {
  /** Track generated schema names to avoid duplicates */
  generatedSchemas: Set<string>;
  /** Track schemas that need to be generated (dependencies) */
  pendingSchemas: Map<string, unknown>;
  /** Schema entries with dependency info for topological sorting */
  schemaEntries: Map<string, SchemaEntry>;
  /** Generated TypeScript type exports (inferred from Zod) */
  typeExports: string[];
  /** Warnings during generation */
  warnings: string[];
}

/**
 * Create a new Zod generation context
 */
export function createZodGenContext(): ZodGenContext {
  return {
    generatedSchemas: new Set(),
    pendingSchemas: new Map(),
    schemaEntries: new Map(),
    typeExports: [],
    warnings: [],
  };
}

/**
 * Convert a type name to a Zod schema variable name
 * e.g., "User" -> "userSchema", "CreateUserRequest" -> "createUserRequestSchema"
 */
export function toSchemaName(typeName: string): string {
  const camelCase = typeName.charAt(0).toLowerCase() + typeName.slice(1);
  return `${camelCase}Schema`;
}

/**
 * Convert a string to PascalCase
 * e.g., "create_user" -> "CreateUser", "create-user" -> "CreateUser"
 */
export function toPascalCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toUpperCase());
}

/**
 * Convert a string to camelCase
 * e.g., "CreateUser" -> "createUser", "create_user" -> "createUser"
 */
export function toCamelCase(str: string): string {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

/**
 * Check if a property name is a valid JavaScript identifier
 * If not, it needs to be quoted in object literals
 */
export function isValidIdentifier(name: string): boolean {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);
}

/**
 * Get a safe property name for use in object literals
 * Quotes the name if it's not a valid identifier
 */
export function getSafePropertyName(name: string): string {
  return isValidIdentifier(name) ? name : `"${name}"`;
}

/**
 * Generate the file header for generated Zod schema files
 */
export function generateZodFileHeader(): string[] {
  return [
    "/* eslint-disable */",
    "/* This file is auto-generated by tangrams. Do not edit. */",
    "",
    'import * as z from "zod"',
    "",
  ];
}

/**
 * Extract dependencies from a Zod type string
 * Finds references to other schemas (e.g., "petCategorySchema" in a type)
 */
export function extractDependencies(zodType: string): Set<string> {
  const deps = new Set<string>();
  // Match schema references like "petCategorySchema", "userSchema", etc.
  const schemaRefPattern = /([a-z][a-zA-Z0-9]*)Schema/g;
  let match = schemaRefPattern.exec(zodType);
  while (match !== null) {
    // Convert schema variable name back to type name
    const schemaVarName = match[0];
    // Extract the base name (e.g., "petCategory" from "petCategorySchema")
    const baseName = schemaVarName.replace(/Schema$/, "");
    // Convert to PascalCase for the type name
    const typeName = baseName.charAt(0).toUpperCase() + baseName.slice(1);
    deps.add(typeName);
    match = schemaRefPattern.exec(zodType);
  }
  return deps;
}

/**
 * Topologically sort schema entries so dependencies come before dependents
 */
export function topologicalSortSchemas(
  entries: Map<string, SchemaEntry>,
): SchemaEntry[] {
  const result: SchemaEntry[] = [];
  const visited = new Set<string>();
  const visiting = new Set<string>(); // For cycle detection

  function visit(name: string): void {
    if (visited.has(name)) return;
    if (visiting.has(name)) {
      // Cycle detected - just return, the schema will be emitted where it is
      return;
    }

    const entry = entries.get(name);
    if (!entry) return;

    visiting.add(name);

    // Visit dependencies first
    for (const dep of entry.dependencies) {
      if (entries.has(dep)) {
        visit(dep);
      }
    }

    visiting.delete(name);
    visited.add(name);
    result.push(entry);
  }

  // Visit all entries
  for (const name of entries.keys()) {
    visit(name);
  }

  return result;
}

/**
 * Build the final output from a Zod generation context
 */
export function buildZodOutput(ctx: ZodGenContext): string {
  const lines: string[] = generateZodFileHeader();

  // Topologically sort schemas so dependencies come first
  const sortedSchemas = topologicalSortSchemas(ctx.schemaEntries);

  // Add Zod schemas in dependency order
  if (sortedSchemas.length > 0) {
    lines.push("// Zod Schemas");
    for (const entry of sortedSchemas) {
      const schemaVarName = toSchemaName(entry.name);
      lines.push(`export const ${schemaVarName} = ${entry.zodType}`);
    }
    lines.push("");
  }

  // Add TypeScript type exports (inferred from Zod)
  if (ctx.typeExports.length > 0) {
    lines.push("// TypeScript Types (inferred from Zod schemas)");
    lines.push(...ctx.typeExports);
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Add a schema to the context with dependency tracking
 */
export function addSchemaToContext(
  ctx: ZodGenContext,
  typeName: string,
  zodType: string,
): void {
  if (ctx.generatedSchemas.has(typeName)) return;

  ctx.generatedSchemas.add(typeName);

  // Extract dependencies from the zod type
  const dependencies = extractDependencies(zodType);
  // Remove self-reference
  dependencies.delete(typeName);

  // Add to schema entries for topological sorting
  ctx.schemaEntries.set(typeName, {
    name: typeName,
    zodType,
    dependencies,
  });

  // Add type export
  const schemaVarName = toSchemaName(typeName);
  ctx.typeExports.push(
    `export type ${typeName} = z.infer<typeof ${schemaVarName}>`,
  );
}

/**
 * Check if a Zod type string is just a reference to another schema
 * (not an inline z.* definition)
 */
export function isSchemaReference(zodType: string): boolean {
  return (
    !zodType.startsWith("z.") && /^[A-Za-z][A-Za-z0-9]*Schema$/.test(zodType)
  );
}
