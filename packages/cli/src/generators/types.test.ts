import { resolve } from "node:path";

import { describe, expect, it } from "vitest";

import { loadDocuments } from "../core/documents";
import { testSchema } from "../test/fixtures/schema";
import { generateTypes } from "./types";

const fixturesDir = resolve(__dirname, "../test/fixtures/graphql");

describe("generateTypes", () => {
  it("generates types file with eslint-disable comment", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toContain("/* eslint-disable */");
  });

  it("generates types file with auto-generated comment", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toContain("auto-generated by tangrams");
  });

  it("only generates enum types that are used by documents", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    // UserRole is not used in user.graphql, so it should NOT be generated
    expect(result.code).not.toContain("export enum UserRole");
  });

  it("generates input types that are used by documents", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    // These are used in user.graphql mutations
    expect(result.code).toContain("export type CreateUserInput");
    expect(result.code).toContain("export type UpdateUserInput");

    // CreatePostInput is NOT used in user.graphql
    expect(result.code).not.toContain("export type CreatePostInput");
  });

  it("generates fragment types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toContain("export type UserFieldsFragment");
  });

  it("generates query return types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toContain("export type GetUserQuery");
    expect(result.code).toContain("export type ListUsersQuery");
  });

  it("generates query variables types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toContain("export type GetUserQueryVariables");
    expect(result.code).toContain("export type ListUsersQueryVariables");
  });

  it("generates mutation return types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toContain("export type CreateUserMutation");
    expect(result.code).toContain("export type UpdateUserMutation");
    expect(result.code).toContain("export type DeleteUserMutation");
  });

  it("generates mutation variables types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toContain("export type CreateUserMutationVariables");
    expect(result.code).toContain("export type UpdateUserMutationVariables");
    expect(result.code).toContain("export type DeleteUserMutationVariables");
  });

  it("uses custom scalar mappings", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
      scalars: { DateTime: "Date" },
    });

    expect(result.code).toContain("Date");
  });

  it("generates empty variables type for operations without variables", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    // DeleteUser has only one required variable, so it should have a variables type
    expect(result.code).toContain("DeleteUserMutationVariables");
  });

  it("handles nullable fields correctly", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    // avatarUrl is nullable in the schema
    expect(result.code).toContain("avatarUrl");
  });

  it("returns empty warnings array when all types exist", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.warnings).toEqual([]);
  });

  it("matches snapshot for user operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toMatchSnapshot();
  });

  it("matches snapshot for post operations with nested fragments", async () => {
    const documents = await loadDocuments([
      `${fixturesDir}/user.graphql`,
      `${fixturesDir}/post.graphql`,
    ]);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result.code).toMatchSnapshot();
  });

  it("matches snapshot with custom scalars", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
      scalars: {
        DateTime: "Date",
        JSON: "Record<string, unknown>",
      },
    });

    expect(result.code).toMatchSnapshot();
  });

  describe("alias handling", () => {
    it("generates correct types for aliased fields", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetMultipleUsers should have firstUser and secondUser, not user
      expect(result.code).toContain("firstUser:");
      expect(result.code).toContain("secondUser:");
    });

    it("generates aliased field names in inline selections", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetUsersWithAliases should use aliased names
      expect(result.code).toContain("allUsers:");
      expect(result.code).toContain("userId:");
      expect(result.code).toContain("userName:");
      expect(result.code).toContain("userEmail:");
    });

    it("supports aliased __typename", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetUserWithTypename should have type: instead of __typename:
      expect(result.code).toContain('type: "User"');
    });

    it("handles mixed aliased and non-aliased fields", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetMixedFields should have both aliased and non-aliased fields
      expect(result.code).toContain("id:");
      expect(result.code).toContain("displayName:");
      expect(result.code).toContain("email:");
      expect(result.code).toContain("avatar:");
    });

    it("matches snapshot for aliased operations", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      expect(result.code).toMatchSnapshot();
    });
  });

  describe("union types", () => {
    it("generates discriminated union type for union fields with inline fragments", async () => {
      const documents = await loadDocuments(`${fixturesDir}/union.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // Should generate discriminated union with __typename
      expect(result.code).toContain('__typename: "User"');
      expect(result.code).toContain('__typename: "Post"');
    });

    it("generates union members with selected fields", async () => {
      const documents = await loadDocuments(`${fixturesDir}/union.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // User variant should have User-specific fields
      expect(result.code).toContain("name:");
      expect(result.code).toContain("email:");

      // Post variant should have Post-specific fields
      expect(result.code).toContain("title:");
      expect(result.code).toContain("content:");
    });

    it("emits warning for union without inline fragments", async () => {
      const documents = await loadDocuments(`${fixturesDir}/union.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // SearchMinimal query has no inline fragments
      expect(result.warnings).toContainEqual(
        expect.stringContaining("SearchResult"),
      );
      expect(result.warnings).toContainEqual(
        expect.stringContaining("inline fragments"),
      );
    });

    it("matches snapshot for union operations", async () => {
      const documents = await loadDocuments(`${fixturesDir}/union.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      expect(result.code).toMatchSnapshot();
    });
  });

  describe("interface types", () => {
    it("generates discriminated union type for interface fields with inline fragments", async () => {
      const documents = await loadDocuments(`${fixturesDir}/interface.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // Should generate discriminated union with __typename
      expect(result.code).toContain('__typename: "User"');
      expect(result.code).toContain('__typename: "Post"');
    });

    it("includes common interface fields in all variants", async () => {
      const documents = await loadDocuments(`${fixturesDir}/interface.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetNode selects id from the interface, should be in generated type
      expect(result.code).toContain("id:");
    });

    it("handles interface with only common fields", async () => {
      const documents = await loadDocuments(`${fixturesDir}/interface.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetNodeMinimal only selects id, should have a simpler type
      expect(result.code).toContain("GetNodeMinimalQuery");
    });

    it("generates fragment types for fragments on interfaces", async () => {
      const documents = await loadDocuments(`${fixturesDir}/interface.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // NodeFields fragment should be generated
      expect(result.code).toContain("NodeFieldsFragment");
    });

    it("matches snapshot for interface operations", async () => {
      const documents = await loadDocuments(`${fixturesDir}/interface.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      expect(result.code).toMatchSnapshot();
    });
  });
});
