/**
 * GraphQL server function generation for TanStack Start
 * Generates createServerFn() wrappers for queries and mutations
 */

import { getFragmentDependencies } from "../core/documents";
import {
  toDocumentName,
  toFragmentDocName,
  toMutationFnName,
  toMutationTypeName,
  toMutationVariablesTypeName,
  toQueryFnName,
  toQueryTypeName,
  toQueryVariablesTypeName,
} from "../utils/naming";

import type {
  ParsedDocuments,
  ParsedFragment,
  ParsedOperation,
} from "../core/documents";

export interface StartGeneratorOptions {
  documents: ParsedDocuments;
  clientImportPath: string;
  typesImportPath: string;
  /** The source name */
  sourceName: string;
}

/**
 * Generate the server functions file with createServerFn wrappers
 */
export function generateStartFunctions(options: StartGeneratorOptions): string {
  const { documents, clientImportPath, typesImportPath } = options;
  const { operations, fragments } = documents;

  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/* This file is auto-generated by tangrams. Do not edit. */");
  lines.push("");

  // Imports
  lines.push(`import { createServerFn } from "@tanstack/react-start"`);
  lines.push(`import { getClient } from "${clientImportPath}"`);
  lines.push("");

  // Type imports
  const typeImports = generateTypeImports(operations);
  if (typeImports) {
    lines.push("import type {");
    lines.push(typeImports);
    lines.push(`} from "${typesImportPath}"`);
    lines.push("");
  }

  // Fragment documents
  if (fragments.length > 0) {
    lines.push("// Fragment Documents");
    for (const fragment of fragments) {
      lines.push(generateFragmentDocument(fragment));
      lines.push("");
    }
  }

  // Operation documents and server functions
  lines.push("// Documents & Server Functions");
  for (const operation of operations) {
    const fragmentDeps = getFragmentDependencies(operation, fragments);
    lines.push(generateOperationDocument(operation, fragmentDeps));
    lines.push("");

    if (operation.operation === "query") {
      lines.push(generateQueryServerFn(operation));
    } else {
      lines.push(generateMutationServerFn(operation));
    }
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate type imports for all operations
 */
function generateTypeImports(operations: ParsedOperation[]): string {
  const imports: string[] = [];

  for (const op of operations) {
    const hasVariables =
      op.node.variableDefinitions && op.node.variableDefinitions.length > 0;

    if (op.operation === "query") {
      imports.push(`\t${toQueryTypeName(op.name)},`);
      if (hasVariables) {
        imports.push(`\t${toQueryVariablesTypeName(op.name)},`);
      }
    } else if (op.operation === "mutation") {
      imports.push(`\t${toMutationTypeName(op.name)},`);
      if (hasVariables) {
        imports.push(`\t${toMutationVariablesTypeName(op.name)},`);
      }
    }
  }

  return imports.join("\n");
}

/**
 * Generate a fragment document constant
 */
function generateFragmentDocument(fragment: ParsedFragment): string {
  const docName = toFragmentDocName(fragment.name);
  return `const ${docName} = /* GraphQL */ \`
${fragment.document}
\``;
}

/**
 * Generate an operation document constant with fragment dependencies
 */
function generateOperationDocument(
  operation: ParsedOperation,
  fragmentDeps: ParsedFragment[],
): string {
  const docName = toDocumentName(operation.name);

  if (fragmentDeps.length === 0) {
    return `const ${docName} = /* GraphQL */ \`
${operation.document}
\``;
  }

  // Build the document with fragment concatenation
  const fragmentConcats = fragmentDeps
    .map((f) => toFragmentDocName(f.name))
    .join(" + ");

  return `const ${docName} = /* GraphQL */ \`
${operation.document}
\` + ${fragmentConcats}`;
}

/**
 * Generate server function for a query operation
 */
function generateQueryServerFn(operation: ParsedOperation): string {
  const fnName = toQueryFnName(operation.name);
  const docName = toDocumentName(operation.name);
  const queryType = toQueryTypeName(operation.name);
  const variablesType = toQueryVariablesTypeName(operation.name);

  const hasVariables =
    operation.node.variableDefinitions &&
    operation.node.variableDefinitions.length > 0;

  if (!hasVariables) {
    return `export const ${fnName} = createServerFn({ method: "GET" })
	.handler(async () =>
		(await getClient()).request<${queryType}>(${docName})
	)`;
  }

  return `export const ${fnName} = createServerFn({ method: "GET" })
	.inputValidator((data: ${variablesType}) => data)
	.handler(async ({ data }) =>
		(await getClient()).request<${queryType}>(${docName}, data)
	)`;
}

/**
 * Generate server function for a mutation operation
 */
function generateMutationServerFn(operation: ParsedOperation): string {
  const fnName = toMutationFnName(operation.name);
  const docName = toDocumentName(operation.name);
  const mutationType = toMutationTypeName(operation.name);
  const variablesType = toMutationVariablesTypeName(operation.name);

  const hasVariables =
    operation.node.variableDefinitions &&
    operation.node.variableDefinitions.length > 0;

  if (!hasVariables) {
    return `export const ${fnName} = createServerFn({ method: "POST" })
	.handler(async () =>
		(await getClient()).request<${mutationType}>(${docName})
	)`;
  }

  return `export const ${fnName} = createServerFn({ method: "POST" })
	.inputValidator((data: ${variablesType}) => data)
	.handler(async ({ data }) =>
		(await getClient()).request<${mutationType}>(${docName}, data)
	)`;
}

/**
 * Get the list of exported server function names for a set of operations
 * Used by operations.ts to generate imports when serverFunctions: true
 */
export function getServerFunctionNames(
  operations: ParsedOperation[],
): string[] {
  return operations.map((op) =>
    op.operation === "query"
      ? toQueryFnName(op.name)
      : toMutationFnName(op.name),
  );
}
