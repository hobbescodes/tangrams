/**
 * TanStack Form options generator
 * Generates formOptions exports for mutations
 */

import { toCamelCase, toPascalCase, toSchemaName } from "./zod/index";

import type { FormOverridesConfig } from "@/core/config";

/**
 * Derive the TypeScript type name from a schema variable name.
 * e.g., "createPetRequestSchema" -> "CreatePetRequest"
 */
function schemaNameToTypeName(schemaName: string): string {
  // Remove "Schema" suffix and ensure PascalCase
  const withoutSuffix = schemaName.replace(/Schema$/, "");
  return toPascalCase(withoutSuffix);
}

/**
 * Information about a mutation operation for form generation
 */
export interface MutationOperation {
  /** Operation ID / name */
  operationId: string;
  /** The Zod schema variable name for the request body */
  requestSchemaName: string;
}

/**
 * Options for form options code generation
 */
export interface FormOptionsGenOptions {
  /** Import path for the schema file */
  schemaImportPath: string;
  /** Form overrides from config (validator, validationLogic) */
  formOverrides?: FormOverridesConfig;
}

/**
 * Result of form options generation
 */
export interface FormOptionsResult {
  /** Generated code content */
  content: string;
  /** Warnings during generation */
  warnings: string[];
}

/**
 * Generate TanStack Form options code for mutations
 */
export function generateFormOptionsCode(
  mutations: MutationOperation[],
  options: FormOptionsGenOptions,
): FormOptionsResult {
  const warnings: string[] = [];

  if (mutations.length === 0) {
    return {
      content: generateEmptyFormFile(),
      warnings: [
        "No mutations found with request bodies to generate form options for.",
      ],
    };
  }

  // Get validator config (default to onSubmitAsync)
  const validator = options.formOverrides?.validator ?? "onSubmitAsync";
  const validationLogic = options.formOverrides?.validationLogic;
  const isOnDynamic = validator === "onDynamic";

  // Warn if validationLogic is set but validator isn't onDynamic
  if (validationLogic && !isOnDynamic) {
    warnings.push(
      `validationLogic is only used with "onDynamic" validator (current: "${validator}"). The validationLogic config will be ignored.`,
    );
  }

  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/* This file is auto-generated by tangrams. Do not edit. */");
  lines.push("");

  // Build formOptions import (add revalidateLogic for onDynamic)
  if (isOnDynamic) {
    lines.push(
      'import { formOptions, revalidateLogic } from "@tanstack/react-form"',
    );
  } else {
    lines.push('import { formOptions } from "@tanstack/react-form"');
  }
  lines.push("");

  // Collect all schema imports and their corresponding type imports
  const schemaImports = mutations.map((m) => m.requestSchemaName);
  const typeImports = mutations.map((m) =>
    schemaNameToTypeName(m.requestSchemaName),
  );

  if (schemaImports.length > 0) {
    // Import schemas as values and types separately for clarity
    lines.push(
      `import { ${schemaImports.join(", ")} } from "${options.schemaImportPath}"`,
    );
    lines.push(
      `import type { ${typeImports.join(", ")} } from "${options.schemaImportPath}"`,
    );
    lines.push("");
  }

  // Generate form options for each mutation
  for (const mutation of mutations) {
    const formOptionsName = `${toCamelCase(mutation.operationId)}FormOptions`;
    const typeName = schemaNameToTypeName(mutation.requestSchemaName);

    lines.push(`export const ${formOptionsName} = formOptions({`);
    lines.push(`  defaultValues: {} as ${typeName},`);

    // Add validationLogic for onDynamic
    if (isOnDynamic) {
      const mode = validationLogic?.mode ?? "submit";
      const modeAfterSubmission =
        validationLogic?.modeAfterSubmission ?? "change";
      lines.push(
        `  validationLogic: revalidateLogic({ mode: "${mode}", modeAfterSubmission: "${modeAfterSubmission}" }),`,
      );
    }

    lines.push(`  validators: {`);
    lines.push(`    ${validator}: ${mutation.requestSchemaName},`);
    lines.push(`  },`);
    lines.push(`})`);
    lines.push("");
  }

  return {
    content: lines.join("\n"),
    warnings,
  };
}

/**
 * Generate an empty form file when no mutations are found
 */
function generateEmptyFormFile(): string {
  return `/* eslint-disable */
/* This file is auto-generated by tangrams. Do not edit. */

// No mutations with request bodies found to generate form options for.
// Add mutations to your schema/documents to generate form options.
`;
}

/**
 * Filter OpenAPI operations to only mutations (POST, PUT, PATCH) with request bodies
 */
export function filterOpenAPIMutations(
  operations: Array<{
    operationId: string;
    method: string;
    requestBody?: unknown;
  }>,
): string[] {
  const mutationMethods = new Set(["post", "put", "patch"]);

  return operations
    .filter((op) => mutationMethods.has(op.method) && op.requestBody)
    .map((op) => op.operationId);
}

/**
 * Filter GraphQL operations to only mutations
 */
export function filterGraphQLMutations(
  operations: Array<{
    name: string;
    operation: "query" | "mutation" | "subscription";
  }>,
): string[] {
  return operations
    .filter((op) => op.operation === "mutation")
    .map((op) => op.name);
}

/**
 * Get the request schema name for an OpenAPI operation
 */
export function getOpenAPIRequestSchemaName(operationId: string): string {
  return toSchemaName(`${toPascalCase(operationId)}Request`);
}

/**
 * Get the request schema name for a GraphQL mutation
 * GraphQL mutations use input types from variables, so we need to look at the variable definitions
 */
export function getGraphQLInputSchemaName(inputTypeName: string): string {
  return toSchemaName(inputTypeName);
}
