/**
 * OpenAPI operations generation
 * Generates TanStack Query helpers for OpenAPI operations using better-fetch
 */

import { extractOperations } from "./schema";

import type { OpenAPISourceConfig } from "@/core/config";
import type {
  GeneratedFile,
  OpenAPIAdapterSchema,
  OperationGenOptions,
} from "../types";
import type { ParsedOperation } from "./schema";

/**
 * Generate TanStack Query operation helpers from OpenAPI spec
 */
export function generateOpenAPIOperations(
  schema: OpenAPIAdapterSchema,
  _config: OpenAPISourceConfig,
  options: OperationGenOptions,
): GeneratedFile {
  const { document } = schema;
  const operations = extractOperations(document);
  const serverFunctions = options.serverFunctions ?? false;

  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/* This file is auto-generated by tangrams. Do not edit. */");
  lines.push("");

  // Separate operations by type
  const queries = operations.filter((op) => ["get"].includes(op.method));
  const mutations = operations.filter((op) =>
    ["post", "put", "patch", "delete"].includes(op.method),
  );

  // Imports
  const tanstackImports: string[] = [];
  if (queries.length > 0) tanstackImports.push("queryOptions");
  if (mutations.length > 0) tanstackImports.push("mutationOptions");

  if (tanstackImports.length > 0) {
    lines.push(
      `import { ${tanstackImports.join(", ")} } from "@tanstack/react-query"`,
    );
  }

  // Add TanStack Start import if server functions are enabled
  if (serverFunctions) {
    lines.push(`import { createServerFn } from "@tanstack/react-start"`);
  }

  lines.push(
    `import { $fetch, buildPath, buildQuery } from "${options.clientImportPath}"`,
  );
  lines.push("");

  // Type and schema imports
  const { typeImports, schemaImports } = generateImports(
    operations,
    serverFunctions,
  );
  if (typeImports || schemaImports) {
    const allImports: string[] = [];
    if (typeImports) allImports.push(typeImports);
    if (schemaImports) allImports.push(schemaImports);

    lines.push("import {");
    lines.push(allImports.join("\n"));
    lines.push(`} from "${options.typesImportPath}"`);
    lines.push("");
  }

  // Always include source name in query keys for consistency
  const queryKeyPrefix = `"${options.sourceName}", `;

  // Generate query options for GET operations
  if (queries.length > 0) {
    lines.push("// Query Options (GET operations)");
    lines.push("");
    for (const op of queries) {
      if (serverFunctions) {
        lines.push(generateQueryServerFn(op));
        lines.push("");
        lines.push(generateQueryOptionWithServerFn(op, queryKeyPrefix));
      } else {
        lines.push(generateQueryOption(op, queryKeyPrefix));
      }
      lines.push("");
    }
  }

  // Generate mutation options for POST/PUT/PATCH/DELETE operations
  if (mutations.length > 0) {
    lines.push("// Mutation Options (POST/PUT/PATCH/DELETE operations)");
    lines.push("");
    for (const op of mutations) {
      if (serverFunctions) {
        lines.push(generateMutationServerFn(op));
        lines.push("");
        lines.push(generateMutationOptionWithServerFn(op, queryKeyPrefix));
      } else {
        lines.push(generateMutationOption(op, queryKeyPrefix));
      }
      lines.push("");
    }
  }

  return {
    filename: "operations.ts",
    content: lines.join("\n"),
  };
}

/**
 * Generate imports for types and schemas
 */
function generateImports(
  operations: ParsedOperation[],
  serverFunctions: boolean,
): { typeImports: string; schemaImports: string } {
  const typeImportsList: string[] = [];
  const schemaImportsList: string[] = [];
  const seenTypes = new Set<string>();
  const seenSchemas = new Set<string>();

  for (const op of operations) {
    const baseName = toPascalCase(op.operationId);
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0;

    // Response type
    if (op.responseSchema) {
      const responseName = `${baseName}Response`;
      if (!seenTypes.has(responseName)) {
        seenTypes.add(responseName);
        typeImportsList.push(`\ttype ${responseName},`);
      }
      // Response schema for runtime validation
      const schemaName = toSchemaName(`${baseName}Response`);
      if (!seenSchemas.has(schemaName)) {
        seenSchemas.add(schemaName);
        schemaImportsList.push(`\t${schemaName},`);
      }
    }

    // Request body type
    if (op.requestBody) {
      const requestName = `${baseName}Request`;
      if (!seenTypes.has(requestName)) {
        seenTypes.add(requestName);
        typeImportsList.push(`\ttype ${requestName},`);
      }
      // Request schema for server function validation
      if (serverFunctions) {
        const schemaName = toSchemaName(`${baseName}Request`);
        if (!seenSchemas.has(schemaName)) {
          seenSchemas.add(schemaName);
          schemaImportsList.push(`\t${schemaName},`);
        }
      }
    }

    // Params type
    if (hasParams) {
      const paramsName = `${baseName}Params`;
      if (!seenTypes.has(paramsName)) {
        seenTypes.add(paramsName);
        typeImportsList.push(`\ttype ${paramsName},`);
      }
      // Params schema for server function validation
      if (serverFunctions) {
        const schemaName = toSchemaName(`${baseName}Params`);
        if (!seenSchemas.has(schemaName)) {
          seenSchemas.add(schemaName);
          schemaImportsList.push(`\t${schemaName},`);
        }
      }
    }
  }

  return {
    typeImports: typeImportsList.join("\n"),
    schemaImports: schemaImportsList.join("\n"),
  };
}

// =============================================================================
// Standard Query/Mutation Options (without server functions)
// =============================================================================

/**
 * Generate queryOptions for a GET operation
 */
function generateQueryOption(op: ParsedOperation, keyPrefix: string): string {
  const baseName = toPascalCase(op.operationId);
  const fnName = `${toCamelCase(op.operationId)}QueryOptions`;
  const hasPathParams = op.pathParams.length > 0;
  const hasQueryParams = op.queryParams.length > 0;
  const hasParams = hasPathParams || hasQueryParams;
  const hasResponse = !!op.responseSchema;

  const paramsType = hasParams ? `${baseName}Params` : null;
  const responseType = hasResponse ? `${baseName}Response` : "unknown";
  const responseSchema = hasResponse
    ? toSchemaName(`${baseName}Response`)
    : null;

  // Build path expression
  let pathExpr: string;
  if (hasPathParams) {
    const pathParamNames = op.pathParams.map((p) => p.name);
    const pathParamsObj = pathParamNames
      .map((n) => `${n}: params.${n}`)
      .join(", ");
    pathExpr = `buildPath("${op.path}", { ${pathParamsObj} })`;
  } else {
    pathExpr = `"${op.path}"`;
  }

  // Build query string expression
  let queryExpr = "";
  if (hasQueryParams) {
    const queryParamNames = op.queryParams.map((p) => p.name);
    const queryParamsObj = queryParamNames
      .map((n) => `${n}: params.${n}`)
      .join(", ");
    queryExpr = `
		const query = buildQuery({ ${queryParamsObj} })
		const url = query ? \`\${path}?\${query}\` : path`;
  }

  // Build function parameters
  const fnParams = hasParams ? `params: ${paramsType}` : "";

  // Build query key
  const queryKey = hasParams
    ? `[${keyPrefix}"${op.operationId}", params]`
    : `[${keyPrefix}"${op.operationId}"]`;

  // Build fetch options
  const fetchOptions = responseSchema ? `{ output: ${responseSchema} }` : "";

  // Generate the function
  if (hasQueryParams) {
    return `export const ${fnName} = (${fnParams}) =>
	queryOptions({
		queryKey: ${queryKey},
		queryFn: async () => {
			const path = ${pathExpr}${queryExpr}
			const { data, error } = await $fetch<${responseType}>(url${fetchOptions ? `, ${fetchOptions}` : ""})
			if (error) throw error
			return data
		},
	})`;
  }

  if (hasPathParams) {
    return `export const ${fnName} = (${fnParams}) =>
	queryOptions({
		queryKey: ${queryKey},
		queryFn: async () => {
			const path = ${pathExpr}
			const { data, error } = await $fetch<${responseType}>(path${fetchOptions ? `, ${fetchOptions}` : ""})
			if (error) throw error
			return data
		},
	})`;
  }

  return `export const ${fnName} = (${fnParams ? fnParams : ""}) =>
	queryOptions({
		queryKey: ${queryKey},
		queryFn: async () => {
			const { data, error } = await $fetch<${responseType}>(${pathExpr}${fetchOptions ? `, ${fetchOptions}` : ""})
			if (error) throw error
			return data
		},
	})`;
}

/**
 * Generate mutationOptions for POST/PUT/PATCH/DELETE operations
 */
function generateMutationOption(
  op: ParsedOperation,
  keyPrefix: string,
): string {
  const baseName = toPascalCase(op.operationId);
  const fnName = `${toCamelCase(op.operationId)}MutationOptions`;
  const hasPathParams = op.pathParams.length > 0;
  const hasBody = !!op.requestBody;
  const hasResponse = !!op.responseSchema;

  const paramsType = hasPathParams ? `${baseName}Params` : null;
  const requestType = hasBody ? `${baseName}Request` : null;
  const responseType = hasResponse ? `${baseName}Response` : "unknown";
  const responseSchema = hasResponse
    ? toSchemaName(`${baseName}Response`)
    : null;

  // Build path expression
  let pathExpr: string;
  if (hasPathParams) {
    const pathParamNames = op.pathParams.map((p) => p.name);
    const pathParamsObj = pathParamNames
      .map((n) => `${n}: params.${n}`)
      .join(", ");
    pathExpr = `buildPath("${op.path}", { ${pathParamsObj} })`;
  } else {
    pathExpr = `"${op.path}"`;
  }

  // Build mutation key
  const mutationKey = `[${keyPrefix}"${op.operationId}"]`;

  // Build fetch options base
  const fetchOptionsBase: string[] = [`method: "${op.method.toUpperCase()}"`];
  if (responseSchema) {
    fetchOptionsBase.push(`output: ${responseSchema}`);
  }

  // Determine mutationFn variables type
  let variablesType: string;
  if (hasPathParams && hasBody) {
    variablesType = `{ params: ${paramsType}, body: ${requestType} }`;
  } else if (hasPathParams) {
    variablesType = `{ params: ${paramsType} }`;
  } else if (hasBody && requestType) {
    variablesType = requestType;
  } else {
    variablesType = "void";
  }

  // Generate the function body based on params/body combinations
  if (hasPathParams && hasBody) {
    return `export const ${fnName} = () =>
	mutationOptions({
		mutationKey: ${mutationKey},
		mutationFn: async (variables: ${variablesType}) => {
			const path = buildPath("${op.path}", { ${op.pathParams.map((p) => `${p.name}: variables.params.${p.name}`).join(", ")} })
			const { data, error } = await $fetch<${responseType}>(path, {
				${fetchOptionsBase.join(",\n\t\t\t\t")},
				body: variables.body,
			})
			if (error) throw error
			return data
		},
	})`;
  }

  if (hasPathParams) {
    return `export const ${fnName} = () =>
	mutationOptions({
		mutationKey: ${mutationKey},
		mutationFn: async (variables: ${variablesType}) => {
			const path = buildPath("${op.path}", { ${op.pathParams.map((p) => `${p.name}: variables.params.${p.name}`).join(", ")} })
			const { data, error } = await $fetch<${responseType}>(path, {
				${fetchOptionsBase.join(",\n\t\t\t\t")},
			})
			if (error) throw error
			return data
		},
	})`;
  }

  if (hasBody) {
    return `export const ${fnName} = () =>
	mutationOptions({
		mutationKey: ${mutationKey},
		mutationFn: async (body: ${variablesType}) => {
			const { data, error } = await $fetch<${responseType}>(${pathExpr}, {
				${fetchOptionsBase.join(",\n\t\t\t\t")},
				body,
			})
			if (error) throw error
			return data
		},
	})`;
  }

  return `export const ${fnName} = () =>
	mutationOptions({
		mutationKey: ${mutationKey},
		mutationFn: async () => {
			const { data, error } = await $fetch<${responseType}>(${pathExpr}, {
				${fetchOptionsBase.join(",\n\t\t\t\t")},
			})
			if (error) throw error
			return data
		},
	})`;
}

// =============================================================================
// Server Function Generation (TanStack Start with Zod validation)
// =============================================================================

/**
 * Generate server function for a GET operation
 */
function generateQueryServerFn(op: ParsedOperation): string {
  const baseName = toPascalCase(op.operationId);
  const fnName = `${toCamelCase(op.operationId)}Fn`;
  const hasPathParams = op.pathParams.length > 0;
  const hasQueryParams = op.queryParams.length > 0;
  const hasParams = hasPathParams || hasQueryParams;
  const hasResponse = !!op.responseSchema;

  const paramsSchema = hasParams ? toSchemaName(`${baseName}Params`) : null;
  const responseType = hasResponse ? `${baseName}Response` : "unknown";
  const responseSchema = hasResponse
    ? toSchemaName(`${baseName}Response`)
    : null;

  // Build the fetch body
  const fetchBody = generateFetchBody(op, responseType, responseSchema, "data");

  if (!hasParams) {
    return `export const ${fnName} = createServerFn({ method: "GET" })
	.handler(async () => {
${fetchBody}
	})`;
  }

  return `export const ${fnName} = createServerFn({ method: "GET" })
	.validator(${paramsSchema})
	.handler(async ({ data }) => {
${fetchBody}
	})`;
}

/**
 * Generate queryOptions that uses server function
 */
function generateQueryOptionWithServerFn(
  op: ParsedOperation,
  keyPrefix: string,
): string {
  const baseName = toPascalCase(op.operationId);
  const optionsFnName = `${toCamelCase(op.operationId)}QueryOptions`;
  const serverFnName = `${toCamelCase(op.operationId)}Fn`;
  const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0;
  const paramsType = hasParams ? `${baseName}Params` : null;

  const queryKey = hasParams
    ? `[${keyPrefix}"${op.operationId}", params]`
    : `[${keyPrefix}"${op.operationId}"]`;

  if (!hasParams) {
    return `export const ${optionsFnName} = () =>
	queryOptions({
		queryKey: ${queryKey},
		queryFn: () => ${serverFnName}(),
	})`;
  }

  return `export const ${optionsFnName} = (params: ${paramsType}) =>
	queryOptions({
		queryKey: ${queryKey},
		queryFn: () => ${serverFnName}({ data: params }),
	})`;
}

/**
 * Generate server function for a mutation operation
 */
function generateMutationServerFn(op: ParsedOperation): string {
  const baseName = toPascalCase(op.operationId);
  const fnName = `${toCamelCase(op.operationId)}Fn`;
  const hasPathParams = op.pathParams.length > 0;
  const hasBody = !!op.requestBody;
  const hasResponse = !!op.responseSchema;

  const responseType = hasResponse ? `${baseName}Response` : "unknown";
  const responseSchema = hasResponse
    ? toSchemaName(`${baseName}Response`)
    : null;

  // Build the fetch body
  const fetchBody = generateMutationFetchBody(
    op,
    responseType,
    responseSchema,
    "data",
  );

  // Determine validator schema based on what params we have
  let validatorSchema: string;
  if (hasPathParams && hasBody) {
    // Use type-only validation for combined params + body (Zod doesn't have a convenient way to combine)
    validatorSchema = `(data: { params: ${baseName}Params, body: ${baseName}Request }) => data`;
  } else if (hasPathParams) {
    // Use type-only validation for params object wrapper
    validatorSchema = `(data: { params: ${baseName}Params }) => data`;
  } else if (hasBody) {
    // Use Zod schema for request body validation
    validatorSchema = toSchemaName(`${baseName}Request`);
  } else {
    // No params or body
    return `export const ${fnName} = createServerFn({ method: "POST" })
	.handler(async () => {
${fetchBody}
	})`;
  }

  return `export const ${fnName} = createServerFn({ method: "POST" })
	.validator(${validatorSchema})
	.handler(async ({ data }) => {
${fetchBody}
	})`;
}

/**
 * Generate mutationOptions that uses server function
 */
function generateMutationOptionWithServerFn(
  op: ParsedOperation,
  keyPrefix: string,
): string {
  const baseName = toPascalCase(op.operationId);
  const optionsFnName = `${toCamelCase(op.operationId)}MutationOptions`;
  const serverFnName = `${toCamelCase(op.operationId)}Fn`;
  const hasPathParams = op.pathParams.length > 0;
  const hasBody = !!op.requestBody;

  const paramsType = hasPathParams ? `${baseName}Params` : null;
  const requestType = hasBody ? `${baseName}Request` : null;
  const mutationKey = `[${keyPrefix}"${op.operationId}"]`;

  // Determine variables type
  let variablesType: string;
  if (hasPathParams && hasBody) {
    variablesType = `{ params: ${paramsType}, body: ${requestType} }`;
  } else if (hasPathParams) {
    variablesType = `{ params: ${paramsType} }`;
  } else if (hasBody && requestType) {
    variablesType = requestType;
  } else {
    variablesType = "void";
  }

  if (variablesType === "void") {
    return `export const ${optionsFnName} = () =>
	mutationOptions({
		mutationKey: ${mutationKey},
		mutationFn: () => ${serverFnName}(),
	})`;
  }

  if (hasPathParams || (hasBody && hasPathParams)) {
    return `export const ${optionsFnName} = () =>
	mutationOptions({
		mutationKey: ${mutationKey},
		mutationFn: (variables: ${variablesType}) => ${serverFnName}({ data: variables }),
	})`;
  }

  // Body only case
  return `export const ${optionsFnName} = () =>
	mutationOptions({
		mutationKey: ${mutationKey},
		mutationFn: (body: ${variablesType}) => ${serverFnName}({ data: body }),
	})`;
}

/**
 * Generate fetch body for query server functions
 */
function generateFetchBody(
  op: ParsedOperation,
  responseType: string,
  responseSchema: string | null,
  dataVar: string,
): string {
  const hasPathParams = op.pathParams.length > 0;
  const hasQueryParams = op.queryParams.length > 0;
  const fetchOptions = responseSchema ? `, { output: ${responseSchema} }` : "";

  const lines: string[] = [];

  if (hasPathParams) {
    const pathParamsObj = op.pathParams
      .map((p) => `${p.name}: ${dataVar}.${p.name}`)
      .join(", ");
    lines.push(
      `\t\tconst path = buildPath("${op.path}", { ${pathParamsObj} })`,
    );
  } else {
    lines.push(`\t\tconst path = "${op.path}"`);
  }

  if (hasQueryParams) {
    const queryParamsObj = op.queryParams
      .map((p) => `${p.name}: ${dataVar}.${p.name}`)
      .join(", ");
    lines.push(`\t\tconst query = buildQuery({ ${queryParamsObj} })`);
    lines.push(`\t\tconst url = query ? \`\${path}?\${query}\` : path`);
    lines.push(
      `\t\tconst { data: result, error } = await $fetch<${responseType}>(url${fetchOptions})`,
    );
  } else {
    lines.push(
      `\t\tconst { data: result, error } = await $fetch<${responseType}>(path${fetchOptions})`,
    );
  }

  lines.push(`\t\tif (error) throw error`);
  lines.push(`\t\treturn result`);

  return lines.join("\n");
}

/**
 * Generate fetch body for mutation server functions
 */
function generateMutationFetchBody(
  op: ParsedOperation,
  responseType: string,
  responseSchema: string | null,
  dataVar: string,
): string {
  const hasPathParams = op.pathParams.length > 0;
  const hasBody = !!op.requestBody;

  const fetchOptionsBase: string[] = [`method: "${op.method.toUpperCase()}"`];
  if (responseSchema) {
    fetchOptionsBase.push(`output: ${responseSchema}`);
  }

  const lines: string[] = [];

  if (hasPathParams) {
    const pathParamsObj = op.pathParams
      .map((p) => `${p.name}: ${dataVar}.params.${p.name}`)
      .join(", ");
    lines.push(
      `\t\tconst path = buildPath("${op.path}", { ${pathParamsObj} })`,
    );
  } else {
    lines.push(`\t\tconst path = "${op.path}"`);
  }

  if (hasBody) {
    const bodyExpr = hasPathParams ? `${dataVar}.body` : dataVar;
    fetchOptionsBase.push(`body: ${bodyExpr}`);
  }

  lines.push(
    `\t\tconst { data: result, error } = await $fetch<${responseType}>(path, {`,
  );
  lines.push(`\t\t\t${fetchOptionsBase.join(",\n\t\t\t")},`);
  lines.push(`\t\t})`);
  lines.push(`\t\tif (error) throw error`);
  lines.push(`\t\treturn result`);

  return lines.join("\n");
}

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toUpperCase());
}

/**
 * Convert a string to camelCase
 */
function toCamelCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toLowerCase());
}

/**
 * Convert a type name to a Zod schema variable name
 */
function toSchemaName(typeName: string): string {
  const camelCase = typeName.charAt(0).toLowerCase() + typeName.slice(1);
  return `${camelCase}Schema`;
}
