/**
 * OpenAPI standalone functions generation
 *
 * Generates standalone async fetch functions for OpenAPI operations.
 * These functions are imported by both operations.ts (for queryOptions/mutationOptions)
 * and collections.ts (for TanStack DB persistence handlers).
 */

import type { GeneratedFile } from "../types";
import type { ParsedOperation } from "./schema";

export interface OpenAPIFunctionsGenOptions {
  /** Relative import path to the client file */
  clientImportPath: string;
  /** Relative import path to the schema file */
  schemaImportPath: string;
}

/**
 * Generate standalone fetch functions from OpenAPI spec
 */
export function generateOpenAPIFunctions(
  operations: ParsedOperation[],
  options: OpenAPIFunctionsGenOptions,
): GeneratedFile {
  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/* This file is auto-generated by tangrams. Do not edit. */");
  lines.push("");

  // Separate operations by type
  const queries = operations.filter((op) => ["get"].includes(op.method));
  const mutations = operations.filter((op) =>
    ["post", "put", "patch", "delete"].includes(op.method),
  );

  // Import client helpers
  lines.push(
    `import { $fetch, buildPath, buildQuery } from "${options.clientImportPath}"`,
  );
  lines.push("");

  // Type and schema imports
  const { typeImports, schemaImports } = generateImports(operations);
  if (typeImports || schemaImports) {
    const allImports: string[] = [];
    if (typeImports) allImports.push(typeImports);
    if (schemaImports) allImports.push(schemaImports);

    lines.push("import {");
    lines.push(allImports.join("\n"));
    lines.push(`} from "${options.schemaImportPath}"`);
    lines.push("");
  }

  // Generate query functions for GET operations
  if (queries.length > 0) {
    lines.push("// Query Functions (GET operations)");
    lines.push("");
    for (const op of queries) {
      lines.push(generateQueryFunction(op));
      lines.push("");
    }
  }

  // Generate mutation functions for POST/PUT/PATCH/DELETE operations
  if (mutations.length > 0) {
    lines.push("// Mutation Functions (POST/PUT/PATCH/DELETE operations)");
    lines.push("");
    for (const op of mutations) {
      lines.push(generateMutationFunction(op));
      lines.push("");
    }
  }

  return {
    filename: "functions.ts",
    content: lines.join("\n"),
  };
}

/**
 * Generate imports for types and schemas
 */
function generateImports(operations: ParsedOperation[]): {
  typeImports: string;
  schemaImports: string;
} {
  const typeImportsList: string[] = [];
  const schemaImportsList: string[] = [];
  const seenTypes = new Set<string>();
  const seenSchemas = new Set<string>();

  for (const op of operations) {
    const baseName = toPascalCase(op.operationId);
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0;

    // Response type
    if (op.responseSchema) {
      const responseName = `${baseName}Response`;
      if (!seenTypes.has(responseName)) {
        seenTypes.add(responseName);
        typeImportsList.push(`\ttype ${responseName},`);
      }
      // Response schema for runtime validation
      const schemaName = toSchemaName(`${baseName}Response`);
      if (!seenSchemas.has(schemaName)) {
        seenSchemas.add(schemaName);
        schemaImportsList.push(`\t${schemaName},`);
      }
    }

    // Request body type
    if (op.requestBody) {
      const requestName = `${baseName}Request`;
      if (!seenTypes.has(requestName)) {
        seenTypes.add(requestName);
        typeImportsList.push(`\ttype ${requestName},`);
      }
    }

    // Params type
    if (hasParams) {
      const paramsName = `${baseName}Params`;
      if (!seenTypes.has(paramsName)) {
        seenTypes.add(paramsName);
        typeImportsList.push(`\ttype ${paramsName},`);
      }
    }
  }

  return {
    typeImports: typeImportsList.join("\n"),
    schemaImports: schemaImportsList.join("\n"),
  };
}

/**
 * Generate a standalone async function for a GET operation
 */
function generateQueryFunction(op: ParsedOperation): string {
  const baseName = toPascalCase(op.operationId);
  const fnName = toCamelCase(op.operationId);
  const hasPathParams = op.pathParams.length > 0;
  const hasQueryParams = op.queryParams.length > 0;
  const hasParams = hasPathParams || hasQueryParams;
  const hasResponse = !!op.responseSchema;

  const paramsType = hasParams ? `${baseName}Params` : null;
  const responseType = hasResponse ? `${baseName}Response` : "unknown";
  const responseSchema = hasResponse
    ? toSchemaName(`${baseName}Response`)
    : null;

  // Build path expression
  let pathExpr: string;
  if (hasPathParams) {
    const pathParamNames = op.pathParams.map((p) => p.name);
    const pathParamsObj = pathParamNames
      .map((n) => `${n}: params.${n}`)
      .join(", ");
    pathExpr = `buildPath("${op.path}", { ${pathParamsObj} })`;
  } else {
    pathExpr = `"${op.path}"`;
  }

  // Build query string expression
  let queryExpr = "";
  if (hasQueryParams) {
    const queryParamNames = op.queryParams.map((p) => p.name);
    const queryParamsObj = queryParamNames
      .map((n) => `${n}: params?.${n}`)
      .join(", ");
    queryExpr = `
	const query = buildQuery({ ${queryParamsObj} })
	const url = query ? \`\${path}?\${query}\` : path`;
  }

  // Build fetch options
  const fetchOptions = responseSchema ? `{ output: ${responseSchema} }` : "";

  // Generate the function
  if (hasQueryParams) {
    return `export const ${fnName} = async (params?: ${paramsType}) => {
	const path = ${pathExpr}${queryExpr}
	const { data, error } = await $fetch<${responseType}>(url${fetchOptions ? `, ${fetchOptions}` : ""})
	if (error) throw error
	return data
}`;
  }

  if (hasPathParams) {
    return `export const ${fnName} = async (params: ${paramsType}) => {
	const path = ${pathExpr}
	const { data, error } = await $fetch<${responseType}>(path${fetchOptions ? `, ${fetchOptions}` : ""})
	if (error) throw error
	return data
}`;
  }

  return `export const ${fnName} = async () => {
	const { data, error } = await $fetch<${responseType}>(${pathExpr}${fetchOptions ? `, ${fetchOptions}` : ""})
	if (error) throw error
	return data
}`;
}

/**
 * Generate a standalone async function for a POST/PUT/PATCH/DELETE operation
 */
function generateMutationFunction(op: ParsedOperation): string {
  const baseName = toPascalCase(op.operationId);
  const fnName = toCamelCase(op.operationId);
  const hasPathParams = op.pathParams.length > 0;
  const hasBody = !!op.requestBody;
  const hasResponse = !!op.responseSchema;

  const requestType = hasBody ? `${baseName}Request` : null;
  const responseType = hasResponse ? `${baseName}Response` : "unknown";
  const responseSchema = hasResponse
    ? toSchemaName(`${baseName}Response`)
    : null;

  // Build fetch options base
  const fetchOptionsBase: string[] = [`method: "${op.method.toUpperCase()}"`];
  if (responseSchema) {
    fetchOptionsBase.push(`output: ${responseSchema}`);
  }

  // Generate the function body based on params/body combinations
  if (hasPathParams && hasBody) {
    const pathParamNames = op.pathParams.map((p) => p.name);
    const pathParamsObj = pathParamNames.map((n) => `${n}`).join(", ");

    // Build the parameter type - use string for path params (most common)
    const paramsList = pathParamNames.map((n) => `${n}: string`);
    paramsList.push(`body: ${requestType}`);

    return `export const ${fnName} = async ({ ${pathParamNames.join(", ")}, body }: { ${paramsList.join("; ")} }) => {
	const path = buildPath("${op.path}", { ${pathParamsObj} })
	const { data, error } = await $fetch<${responseType}>(path, {
		${fetchOptionsBase.join(",\n\t\t")},
		body,
	})
	if (error) throw error
	return data
}`;
  }

  if (hasPathParams) {
    const pathParamNames = op.pathParams.map((p) => p.name);
    const pathParamsObj = pathParamNames.map((n) => `${n}`).join(", ");

    // Build the parameter type - use string for path params (most common)
    const paramsList = pathParamNames.map((n) => `${n}: string`);

    return `export const ${fnName} = async ({ ${pathParamNames.join(", ")} }: { ${paramsList.join("; ")} }) => {
	const path = buildPath("${op.path}", { ${pathParamsObj} })
	const { data, error } = await $fetch<${responseType}>(path, {
		${fetchOptionsBase.join(",\n\t\t")},
	})
	if (error) throw error
	return data
}`;
  }

  if (hasBody) {
    return `export const ${fnName} = async ({ body }: { body: ${requestType} }) => {
	const { data, error } = await $fetch<${responseType}>("${op.path}", {
		${fetchOptionsBase.join(",\n\t\t")},
		body,
	})
	if (error) throw error
	return data
}`;
  }

  return `export const ${fnName} = async () => {
	const { data, error } = await $fetch<${responseType}>("${op.path}", {
		${fetchOptionsBase.join(",\n\t\t")},
	})
	if (error) throw error
	return data
}`;
}

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toUpperCase());
}

/**
 * Convert a string to camelCase
 */
function toCamelCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toLowerCase());
}

/**
 * Convert a type name to a Zod schema variable name
 */
function toSchemaName(typeName: string): string {
  const camelCase = typeName.charAt(0).toLowerCase() + typeName.slice(1);
  return `${camelCase}Schema`;
}
