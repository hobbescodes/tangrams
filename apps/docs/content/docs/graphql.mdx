---
title: GraphQL
description: Generate TanStack Query pieces from your GraphQL schema.
---

# GraphQL

Tangrams takes your GraphQL schema and operations and generates perfectly-shaped pieces for TanStack Query - `queryOptions` and `mutationOptions` ready to snap into your hooks.

## Setup

### 1. Initialize Configuration

```bash
bunx tangrams init
```

### 2. Configure Your Schema

Edit `tangrams.config.ts`:

```typescript
import { defineConfig } from "tangrams"

export default defineConfig({
  sources: [
    {
      name: "graphql",
      type: "graphql",
      schema: {
        // URL-based introspection
        url: "http://localhost:4000/graphql",
        // Or file-based
        // file: "./schema.graphql",
      },
      documents: "./src/graphql/**/*.graphql",
      generates: ["query"],
    },
  ],
})
```

### 3. Write Your Operations

Create `.graphql` files with your queries and mutations:

```graphql
# src/graphql/user.graphql

fragment UserFields on User {
  id
  name
  email
}

query GetUser($id: ID!) {
  user(id: $id) {
    ...UserFields
  }
}

mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
  updateUser(id: $id, input: $input) {
    ...UserFields
  }
}
```

### 4. Generate

```bash
bunx tangrams generate
```

## Generated Pieces

### Query Options

Every GraphQL query becomes a `queryOptions` function:

```typescript
// Generated: operations.ts
export const getUserQueryOptions = (variables: GetUserQueryVariables) =>
  queryOptions({
    queryKey: ["graphql", "GetUser", variables],
    queryFn: async () =>
      (await getClient()).request<GetUserQuery>(GetUserDocument, variables),
  })
```

### Mutation Options

Every mutation becomes a `mutationOptions` function:

```typescript
export const updateUserMutationOptions = () =>
  mutationOptions({
    mutationKey: ["graphql", "UpdateUser"],
    mutationFn: async (variables: UpdateUserMutationVariables) =>
      (await getClient()).request<UpdateUserMutation>(
        UpdateUserDocument,
        variables
      ),
  })
```

## Usage

The generated pieces snap right into TanStack Query:

```typescript
import { useQuery, useMutation } from "@tanstack/react-query"
import {
  getUserQueryOptions,
  updateUserMutationOptions,
} from "./generated/operations"

function UserProfile({ userId }: { userId: string }) {
  // Fully typed - variables, response, and cache keys
  const { data, isLoading } = useQuery(getUserQueryOptions({ id: userId }))

  const { mutate } = useMutation(updateUserMutationOptions())

  if (isLoading) return <div>Loading...</div>

  return (
    <div>
      <h1>{data?.user?.name}</h1>
      <button onClick={() => mutate({ id: userId, input: { name: "New Name" } })}>
        Update
      </button>
    </div>
  )
}
```

## Custom Scalars

Map GraphQL scalars to TypeScript types:

```typescript
{
  name: "graphql",
  type: "graphql",
  schema: { url: "..." },
  documents: "...",
  scalars: {
    DateTime: "Date",
    JSON: "Record<string, unknown>",
  },
  generates: ["query"],
}
```

### Default Mappings

| GraphQL | TypeScript |
|---------|------------|
| `ID` | `string` |
| `String` | `string` |
| `Int` | `number` |
| `Float` | `number` |
| `Boolean` | `boolean` |
| `DateTime` | `string` |
| `JSON` | `unknown` |

## Configuration

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `name` | `string` | Yes | Unique identifier for this source |
| `type` | `"graphql"` | Yes | Source type |
| `schema.url` | `string` | * | GraphQL endpoint for introspection |
| `schema.file` | `string` | * | Path to SDL file(s) |
| `documents` | `string` | Yes | Glob pattern for `.graphql` files |
| `scalars` | `object` | No | Custom scalar mappings |
| `generates` | `array` | Yes | What to generate (`["query"]`, `["form"]`, or both) |

*Either `schema.url` or `schema.file` is required.
