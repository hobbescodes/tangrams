---
title: TanStack Query
description: Generate queryOptions and mutationOptions for TanStack Query.
---

# TanStack Query

Tangrams generates `queryOptions` and `mutationOptions` that snap right into TanStack Query hooks like `useQuery`, `useSuspenseQuery`, and `useMutation`.

## Peer Dependencies

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

Install the required dependencies based on your data source:

### Core

<Tabs items={['bun', 'npm', 'pnpm']}>
  <Tab value="bun">
```bash
bun add @tanstack/react-query
```
  </Tab>
  <Tab value="npm">
```bash
npm install @tanstack/react-query
```
  </Tab>
  <Tab value="pnpm">
```bash
pnpm add @tanstack/react-query
```
  </Tab>
</Tabs>

### Validation Library

Install your chosen validator (Zod is the default). See [Validator Libraries](/docs#validator-libraries) for details.

<Tabs items={['Zod', 'Valibot', 'ArkType']}>
  <Tab value="Zod">
```bash
bun add zod
```
  </Tab>
  <Tab value="Valibot">
```bash
bun add valibot
```
  </Tab>
  <Tab value="ArkType">
```bash
bun add arktype
```
  </Tab>
</Tabs>

### GraphQL Sources

<Tabs items={['bun', 'npm', 'pnpm']}>
  <Tab value="bun">
```bash
bun add graphql-request
```
  </Tab>
  <Tab value="npm">
```bash
npm install graphql-request
```
  </Tab>
  <Tab value="pnpm">
```bash
pnpm add graphql-request
```
  </Tab>
</Tabs>

### OpenAPI Sources

<Tabs items={['bun', 'npm', 'pnpm']}>
  <Tab value="bun">
```bash
bun add @better-fetch/fetch
```
  </Tab>
  <Tab value="npm">
```bash
npm install @better-fetch/fetch
```
  </Tab>
  <Tab value="pnpm">
```bash
pnpm add @better-fetch/fetch
```
  </Tab>
</Tabs>

## Setup

### GraphQL Source

Configure a GraphQL source with either URL-based introspection or local SDL files:

**URL-based (introspection):**

```typescript
import { defineConfig } from "tangrams"

export default defineConfig({
  sources: [
    {
      name: "graphql",
      type: "graphql",
      schema: {
        url: "http://localhost:4000/graphql",
        // headers: { "x-api-key": process.env.API_KEY },
      },
      documents: "./src/graphql/**/*.graphql",
      generates: ["query"],
    },
  ],
})
```

**File-based (local SDL files):**

```typescript
import { defineConfig } from "tangrams"

export default defineConfig({
  sources: [
    {
      name: "graphql",
      type: "graphql",
      schema: {
        file: "./schema.graphql",
        // Or multiple files:
        // file: ["./schema.graphql", "./extensions/**/*.graphql"],
      },
      documents: "./src/graphql/**/*.graphql",
      generates: ["query"],
    },
  ],
})
```

Then create your GraphQL operations in `.graphql` files:

```graphql
# src/graphql/user.graphql

query GetUser($id: ID!) {
  user(id: $id) {
    id
    name
    email
  }
}

mutation CreateUser($input: CreateUserInput!) {
  createUser(input: $input) {
    id
    name
  }
}
```

### OpenAPI Source

Configure an OpenAPI source with a local file or remote URL:

```typescript
import { defineConfig } from "tangrams"

export default defineConfig({
  sources: [
    {
      name: "api",
      type: "openapi",
      spec: "./openapi.yaml", // or a remote URL
      generates: ["query"],
    },
  ],
})
```

**With path filtering:**

```typescript
{
  name: "api",
  type: "openapi",
  spec: "./openapi.yaml",
  include: ["/users/**", "/posts/**"],
  exclude: ["/internal/**"],
  generates: ["query"],
}
```

### Generate

Run the generator:

```bash
bunx tangrams generate
```

## Generated Output

### Output Directory Structure

```
tangrams/
└── <source>/
    ├── client.ts             # API client (shared)
    ├── schema.ts             # Validation schemas + TypeScript types
    ├── functions.ts          # Standalone fetch functions (auto-generated)
    └── query/
        └── options.ts        # queryOptions and mutationOptions
```

### GraphQL Output

**`client.ts`** - A configured `graphql-request` client:

```typescript
import { GraphQLClient } from "graphql-request"

const endpoint = "http://localhost:4000/graphql"

export const getClient = async () => {
  return new GraphQLClient(endpoint, {
    headers: {
      // Add your headers here
    },
  })
}
```

**`schema.ts`** - Validation schemas and TypeScript types from your schema and operations (shown with Zod, the default):

```typescript
import * as z from "zod"

// Operation variable schemas
export const getUserQueryVariablesSchema = z.object({
  id: z.string(),
})

// Operation response schemas
export const getUserQuerySchema = z.object({
  user: z.object({
    id: z.string(),
    name: z.string(),
    email: z.string(),
  }).nullable(),
})

// TypeScript Types (inferred from Zod schemas)
export type GetUserQueryVariables = z.infer<typeof getUserQueryVariablesSchema>
export type GetUserQuery = z.infer<typeof getUserQuerySchema>
```

**`options.ts`** - Ready-to-use query and mutation options:

```typescript
import { queryOptions, mutationOptions } from "@tanstack/react-query"
import { getUser, createUser } from "../functions"
import type { GetUserQueryVariables, CreateUserMutationVariables } from "../schema"

export const getUserQueryOptions = (variables: GetUserQueryVariables) =>
  queryOptions({
    queryKey: ["graphql", "GetUser", variables],
    queryFn: () => getUser(variables),
  })

export const createUserMutationOptions = () =>
  mutationOptions({
    mutationKey: ["graphql", "CreateUser"],
    mutationFn: (variables: CreateUserMutationVariables) => createUser(variables),
  })
```

### OpenAPI Output

**`<source>/schema.ts`** - Validation schemas and inferred TypeScript types (shown with Zod, the default):

```typescript
import * as z from "zod"

export const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string(),
})

export const createUserRequestSchema = z.object({
  name: z.string(),
  email: z.string(),
})

// Inferred TypeScript types
export type User = z.infer<typeof userSchema>
export type CreateUserRequest = z.infer<typeof createUserRequestSchema>
```

**`client.ts`** - A configured `better-fetch` client with async `getClient` function:

```typescript
import { createFetch } from "@better-fetch/fetch"

const baseURL = "https://api.example.com"

/**
 * Returns a configured fetch client.
 * Customize this function to add dynamic headers (e.g., auth tokens).
 */
export const getClient = async () => {
  return createFetch({
    baseURL,
    headers: {
      // Add your headers here
    },
  })
}
```

**`operations.ts`** - Query and mutation options with schema validation:

```typescript
export const listUsersQueryOptions = (params?: ListUsersParams) =>
  queryOptions({
    queryKey: ["api", "listUsers", params],
    queryFn: async () => {
      const { data, error } = await $fetch<ListUsersResponse>("/users", {
        output: listUsersResponseSchema,
      })
      if (error) throw error
      return data
    },
  })

export const createUserMutationOptions = () =>
  mutationOptions({
    mutationKey: ["api", "createUser"],
    mutationFn: async (body: CreateUserRequest) => {
      const { data, error } = await $fetch<User>("/users", {
        method: "POST",
        output: userSchema,
        body,
      })
      if (error) throw error
      return data
    },
  })
```

## Usage

The generated options snap right into TanStack Query hooks:

```typescript
import { useQuery, useSuspenseQuery, useMutation } from "@tanstack/react-query"
import {
  getUserQueryOptions,
  createUserMutationOptions,
} from "./generated/graphql/query/operations"

function UserProfile({ userId }: { userId: string }) {
  // useQuery with full type inference
  const { data, isLoading } = useQuery(getUserQueryOptions({ id: userId }))

  if (isLoading) return <div>Loading...</div>

  return <div>{data?.user?.name}</div>
}

function UserProfileSuspense({ userId }: { userId: string }) {
  // useSuspenseQuery - data is never undefined
  const { data } = useSuspenseQuery(getUserQueryOptions({ id: userId }))

  return <div>{data.user?.name}</div>
}

function CreateUserButton() {
  const { mutate, isPending } = useMutation(createUserMutationOptions())

  return (
    <button
      disabled={isPending}
      onClick={() => mutate({ input: { name: "Jane", email: "jane@example.com" } })}
    >
      {isPending ? "Creating..." : "Create User"}
    </button>
  )
}
```

## Configuration Reference

### GraphQL Source Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `name` | `string` | Yes | Unique name for this source (lowercase alphanumeric with hyphens, starting with a letter) |
| `type` | `"graphql"` | Yes | Source type |
| `schema` | `object` | Yes | Schema configuration (see below) |
| `documents` | `string \| string[]` | Yes | Glob pattern(s) for `.graphql` operation files |
| `generates` | `array` | Yes | What to generate: `["query"]`, `["query", "form"]`, `["db"]`, etc. |
| `overrides` | `object` | No | Override scalars, DB, and form settings (see [Configuration Reference](/docs#overrides-configuration)) |

#### Schema Configuration

**URL-based (introspection):**

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `schema.url` | `string` | Yes | GraphQL endpoint URL for introspection |
| `schema.headers` | `Record<string, string>` | No | Headers to send with introspection request |

**File-based (local SDL files):**

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `schema.file` | `string \| string[]` | Yes | Path or glob pattern(s) for `.graphql` schema files |

### OpenAPI Source Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `name` | `string` | Yes | Unique name for this source (lowercase alphanumeric with hyphens, starting with a letter) |
| `type` | `"openapi"` | Yes | Source type |
| `spec` | `string` | Yes | Path to OpenAPI spec (local file or URL) |
| `headers` | `Record<string, string>` | No | Headers for fetching remote spec |
| `include` | `string[]` | No | Glob patterns for paths to include |
| `exclude` | `string[]` | No | Glob patterns for paths to exclude |
| `generates` | `array` | Yes | What to generate: `["query"]`, `["query", "form"]`, `["db"]`, etc. |
| `overrides` | `object` | No | Override DB and form settings (see [Configuration Reference](/docs#overrides-configuration)) |

### Custom Scalars (GraphQL)

Map GraphQL scalars to TypeScript types using `overrides.scalars`:

```typescript
{
  name: "graphql",
  type: "graphql",
  schema: { url: "..." },
  documents: "...",
  generates: ["query"],
  overrides: {
    scalars: {
      DateTime: "Date",
      JSON: "Record<string, unknown>",
    },
  },
}
```

#### Default Scalar Mappings

| GraphQL Scalar | TypeScript Type |
|----------------|-----------------|
| `ID` | `string` |
| `String` | `string` |
| `Int` | `number` |
| `Float` | `number` |
| `Boolean` | `boolean` |
| `DateTime` | `string` |
| `Date` | `string` |
| `JSON` | `unknown` |
| `BigInt` | `bigint` |
| `UUID` | `string` |

## Infinite Query Options

Tangrams automatically generates `infiniteQueryOptions` for paginated queries alongside the regular `queryOptions`. This enables seamless integration with TanStack Query's `useInfiniteQuery` hook for "load more" or "infinite scroll" patterns.

### Supported Pagination Styles

Tangrams detects pagination patterns from your schema and generates the appropriate `getNextPageParam` logic:

| Style | Parameters | Response Fields | Example |
|-------|------------|-----------------|---------|
| **Cursor** | `cursor`, `after` | `nextCursor`, `endCursor` | GraphQL Relay connections |
| **Offset** | `offset` + `limit` | `total` | REST APIs with total count |
| **Page** | `page` + `pageSize`/`perPage` | `totalPages` | Traditional pagination |
| **Relay** | `first`/`last` + `after`/`before` | `pageInfo.hasNextPage`, `pageInfo.endCursor` | GraphQL Relay spec |

### Generated Output

For a paginated operation like `listPets` with offset pagination:

```typescript
// Regular query options (always generated)
export const listPetsQueryOptions = (params?: ListPetsParams) =>
  queryOptions({
    queryKey: ["api", "listPets", params],
    queryFn: () => listPets(params),
  })

// Infinite query options (auto-generated for paginated operations)
export const listPetsInfiniteQueryOptions = (params?: Omit<ListPetsParams, "offset">) =>
  infiniteQueryOptions({
    queryKey: ["api", "listPets", "infinite", params],
    queryFn: ({ pageParam }) => listPets({ ...params, offset: pageParam }),
    initialPageParam: 0,
    getNextPageParam: (lastPage, _allPages, lastPageParam) =>
      (lastPageParam ?? 0) + (params?.limit ?? 20) < lastPage.total
        ? (lastPageParam ?? 0) + (params?.limit ?? 20)
        : undefined,
  })
```

For Relay-style cursor pagination (GraphQL):

```typescript
export const getPetsConnectionInfiniteQueryOptions = (
  variables?: Omit<GetPetsConnectionQueryVariables, "after">
) =>
  infiniteQueryOptions({
    queryKey: ["api", "GetPetsConnection", "infinite", variables],
    queryFn: ({ pageParam }) => getPetsConnection({ ...variables, after: pageParam }),
    initialPageParam: undefined as string | undefined,
    getNextPageParam: (lastPage) =>
      lastPage.petsConnection?.pageInfo?.hasNextPage
        ? lastPage.petsConnection?.pageInfo?.endCursor
        : undefined,
  })
```

### Usage

```typescript
import { useInfiniteQuery } from "@tanstack/react-query"
import { listPetsInfiniteQueryOptions } from "./tangrams/api/query/options"

function PetList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery(listPetsInfiniteQueryOptions({ limit: 10 }))

  return (
    <div>
      {data?.pages.map((page) =>
        page.data.map((pet) => <PetCard key={pet.id} pet={pet} />)
      )}

      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage ? "Loading..." : hasNextPage ? "Load More" : "No more pets"}
      </button>
    </div>
  )
}
```

### Configuration

You can customize or disable infinite query generation per operation:

```typescript
import { defineConfig } from "tangrams"

export default defineConfig({
  sources: [
    {
      name: "api",
      type: "openapi",
      spec: "./openapi.yaml",
      generates: ["query"],
      overrides: {
        query: {
          operations: {
            // Custom getNextPageParam path
            listPets: {
              getNextPageParamPath: "meta.pagination.nextCursor",
            },
            // Disable infinite query for specific operation
            searchUsers: {
              disabled: true,
            },
          },
        },
      },
    },
  ],
})
```

| Option | Type | Description |
|--------|------|-------------|
| `getNextPageParamPath` | `string` | Dot-notation path to the next page cursor in the response (e.g., `"meta.nextCursor"`) |
| `initialPageParam` | `string \| number` | Override the initial page parameter value |
| `disabled` | `boolean` | Disable infinite query generation for this operation |

### Requirements

For automatic infinite query generation, Tangrams needs to detect:

1. **Pagination parameters** in the request (e.g., `offset`, `cursor`, `page`, `after`)
2. **Pagination response fields** that indicate how to get the next page (e.g., `total`, `nextCursor`, `hasNextPage`)

If Tangrams cannot detect the response structure, it will skip infinite query generation and log a warning. You can use `overrides.query.operations.<operationName>.getNextPageParamPath` to explicitly configure the path.

## TanStack DB Integration

Tangrams can also generate TanStack DB collections for local-first data synchronization with optimistic updates. When `"db"` is specified in `generates`, query generation is automatically enabled as well.

For more details, see the [TanStack DB](/docs/tanstack-db) guide.
