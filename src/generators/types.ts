import {
  isEnumType,
  isInputObjectType,
  isListType,
  isNonNullType,
  isObjectType,
  isScalarType,
} from "graphql";

import {
  toFragmentTypeName,
  toMutationTypeName,
  toMutationVariablesTypeName,
  toQueryTypeName,
  toQueryVariablesTypeName,
} from "../utils/naming";
import { resolveScalars } from "../utils/scalars";
import { collectUsedTypes } from "../utils/type-collector";

import type {
  GraphQLEnumType,
  GraphQLInputObjectType,
  GraphQLObjectType,
  GraphQLOutputType,
  GraphQLSchema,
  GraphQLType,
} from "graphql";
import type {
  ParsedDocuments,
  ParsedFragment,
  ParsedOperation,
} from "../core/documents";

export interface TypeGeneratorOptions {
  schema: GraphQLSchema;
  documents: ParsedDocuments;
  scalars?: Record<string, string>;
}

export interface TypeGeneratorResult {
  /** Generated TypeScript code */
  code: string;
  /** Warnings about type references (e.g., unknown types) */
  warnings: string[];
}

/**
 * Generate TypeScript types from schema and operations
 */
export function generateTypes(
  options: TypeGeneratorOptions,
): TypeGeneratorResult {
  const { schema, documents, scalars: userScalars } = options;
  const scalars = resolveScalars(userScalars);

  // Collect only the types that are actually used by the documents
  const { usedTypes, warnings } = collectUsedTypes(schema, documents);

  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/* This file is auto-generated by tangen. Do not edit. */");
  lines.push("");

  // Generate schema types (enums, input types) - only those that are used
  const schemaTypes = generateSchemaTypes(schema, scalars, usedTypes);
  if (schemaTypes) {
    lines.push("// Schema Types");
    lines.push(schemaTypes);
    lines.push("");
  }

  // Generate fragment types
  if (documents.fragments.length > 0) {
    lines.push("// Fragment Types");
    for (const fragment of documents.fragments) {
      const fragmentType = generateFragmentType(
        schema,
        fragment,
        documents.fragments,
        scalars,
      );
      lines.push(fragmentType);
      lines.push("");
    }
  }

  // Generate operation types (query/mutation return types and variables)
  if (documents.operations.length > 0) {
    lines.push("// Operation Types");
    for (const operation of documents.operations) {
      const operationTypes = generateOperationTypes(
        schema,
        operation,
        documents.fragments,
        scalars,
      );
      lines.push(operationTypes);
      lines.push("");
    }
  }

  return {
    code: lines.join("\n"),
    warnings,
  };
}

/**
 * Generate schema-level types (enums, input types)
 * Only generates types that are in the usedTypes set
 */
function generateSchemaTypes(
  schema: GraphQLSchema,
  scalars: Record<string, string>,
  usedTypes: Set<string>,
): string {
  const typeMap = schema.getTypeMap();

  // Separate enums and input types, then sort alphabetically
  const enums: GraphQLEnumType[] = [];
  const inputTypes: GraphQLInputObjectType[] = [];

  for (const [name, type] of Object.entries(typeMap)) {
    // Skip built-in types
    if (name.startsWith("__")) continue;

    // Skip types not used by documents
    if (!usedTypes.has(name)) continue;

    if (isEnumType(type)) {
      enums.push(type);
    } else if (isInputObjectType(type)) {
      inputTypes.push(type);
    }
  }

  // Sort alphabetically for predictable output
  enums.sort((a, b) => a.name.localeCompare(b.name));
  inputTypes.sort((a, b) => a.name.localeCompare(b.name));

  const lines: string[] = [];

  // Generate enums first
  for (const enumType of enums) {
    lines.push(generateEnumType(enumType));
    lines.push("");
  }

  // Generate input types
  for (const inputType of inputTypes) {
    lines.push(generateInputType(inputType, scalars));
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate a TypeScript enum from GraphQL enum
 */
function generateEnumType(type: GraphQLEnumType): string {
  const values = type.getValues();
  const enumValues = values.map((v) => `  ${v.name} = "${v.name}"`).join(",\n");

  return `export enum ${type.name} {\n${enumValues}\n}`;
}

/**
 * Generate a TypeScript type from GraphQL input type
 */
function generateInputType(
  type: GraphQLInputObjectType,
  scalars: Record<string, string>,
): string {
  const fields = type.getFields();
  const fieldDefs = Object.values(fields)
    .map((field) => {
      const tsType = graphqlTypeToTS(field.type, scalars);
      const optional = !isNonNullType(field.type) ? "?" : "";
      return `  ${field.name}${optional}: ${tsType}`;
    })
    .join("\n");

  return `export type ${type.name} = {\n${fieldDefs}\n}`;
}

/**
 * Generate TypeScript type for a fragment
 */
function generateFragmentType(
  schema: GraphQLSchema,
  fragment: ParsedFragment,
  allFragments: ParsedFragment[],
  scalars: Record<string, string>,
): string {
  const typeName = toFragmentTypeName(fragment.name);
  const parentType = schema.getType(fragment.typeName) as GraphQLObjectType;

  if (!parentType || !isObjectType(parentType)) {
    return `export type ${typeName} = unknown // Unable to resolve type ${fragment.typeName}`;
  }

  const { fields, spreadFragments } = extractSelectionFieldsWithSpreads(
    fragment.node.selectionSet,
    parentType,
    schema,
    allFragments,
    scalars,
  );

  // If there are fragment spreads, use intersection type
  if (spreadFragments.length > 0) {
    const spreadTypes = spreadFragments
      .map((f) => toFragmentTypeName(f))
      .join(" & ");
    if (fields) {
      return `export type ${typeName} = ${spreadTypes} & {\n${fields}\n}`;
    }
    return `export type ${typeName} = ${spreadTypes}`;
  }

  return `export type ${typeName} = {\n${fields}\n}`;
}

/**
 * Generate TypeScript types for an operation (return type and variables)
 */
function generateOperationTypes(
  schema: GraphQLSchema,
  operation: ParsedOperation,
  allFragments: ParsedFragment[],
  scalars: Record<string, string>,
): string {
  const lines: string[] = [];

  // Variables type
  const variablesTypeName =
    operation.operation === "query"
      ? toQueryVariablesTypeName(operation.name)
      : toMutationVariablesTypeName(operation.name);

  const variables = operation.node.variableDefinitions;
  if (variables && variables.length > 0) {
    const varFields = variables
      .map((v) => {
        const tsType = graphqlTypeToTS(v.type, scalars);
        const optional = v.type.kind !== "NonNullType" ? "?" : "";
        return `  ${v.variable.name.value}${optional}: ${tsType}`;
      })
      .join("\n");
    lines.push(`export type ${variablesTypeName} = {\n${varFields}\n}`);
  } else {
    lines.push(`export type ${variablesTypeName} = Record<string, never>`);
  }

  lines.push("");

  // Return type
  const returnTypeName =
    operation.operation === "query"
      ? toQueryTypeName(operation.name)
      : toMutationTypeName(operation.name);

  const rootType =
    operation.operation === "query"
      ? schema.getQueryType()
      : schema.getMutationType();

  if (!rootType) {
    lines.push(
      `export type ${returnTypeName} = unknown // No ${operation.operation} type in schema`,
    );
    return lines.join("\n");
  }

  const { fields } = extractSelectionFieldsWithSpreads(
    operation.node.selectionSet,
    rootType,
    schema,
    allFragments,
    scalars,
  );

  lines.push(`export type ${returnTypeName} = {\n${fields}\n}`);

  return lines.join("\n");
}

interface SelectionResult {
  fields: string;
  spreadFragments: string[];
}

/**
 * Extract TypeScript field definitions from a GraphQL selection set
 * Also returns fragment spread names for intersection types
 */
function extractSelectionFieldsWithSpreads(
  selectionSet: { selections: readonly unknown[] } | undefined,
  parentType: GraphQLObjectType,
  schema: GraphQLSchema,
  allFragments: ParsedFragment[],
  scalars: Record<string, string>,
  indent = "  ",
): SelectionResult {
  if (!selectionSet) return { fields: "", spreadFragments: [] };

  const fields: string[] = [];
  const spreadFragments: string[] = [];
  const parentFields = parentType.getFields();

  for (const selection of selectionSet.selections) {
    const sel = selection as {
      kind: string;
      name?: { value: string };
      alias?: { value: string };
      selectionSet?: { selections: readonly unknown[] };
    };

    if (sel.kind === "Field") {
      const fieldName = sel.name?.value; // Schema field name (for type lookup)
      const outputName = sel.alias?.value ?? fieldName; // Use alias if present
      if (!fieldName || !outputName) continue;

      // Handle __typename (can be aliased, though rare)
      if (fieldName === "__typename") {
        fields.push(`${indent}${outputName}: "${parentType.name}"`);
        continue;
      }

      const schemaField = parentFields[fieldName];
      if (!schemaField) continue;

      const fieldType = schemaField.type;
      const tsType = generateFieldType(
        fieldType,
        sel.selectionSet,
        schema,
        allFragments,
        scalars,
        indent,
      );

      const optional = !isNonNullType(fieldType) ? " | null" : "";
      fields.push(`${indent}${outputName}: ${tsType}${optional}`);
    }

    if (sel.kind === "FragmentSpread") {
      const fragmentName = sel.name?.value;
      if (fragmentName) {
        spreadFragments.push(fragmentName);
      }
    }
  }

  return { fields: fields.join("\n"), spreadFragments };
}

/**
 * Generate TypeScript type for a field
 */
function generateFieldType(
  type: GraphQLOutputType,
  selectionSet: { selections: readonly unknown[] } | undefined,
  schema: GraphQLSchema,
  allFragments: ParsedFragment[],
  scalars: Record<string, string>,
  indent: string,
): string {
  // Unwrap NonNull
  if (isNonNullType(type)) {
    return generateFieldType(
      type.ofType,
      selectionSet,
      schema,
      allFragments,
      scalars,
      indent,
    );
  }

  // Handle lists
  if (isListType(type)) {
    const innerType = generateFieldType(
      type.ofType,
      selectionSet,
      schema,
      allFragments,
      scalars,
      indent,
    );
    return `Array<${innerType}>`;
  }

  // Handle scalars
  if (isScalarType(type)) {
    return scalars[type.name] ?? "unknown";
  }

  // Handle enums
  if (isEnumType(type)) {
    return type.name;
  }

  // Handle object types with nested selections
  if (isObjectType(type) && selectionSet) {
    const { fields, spreadFragments } = extractSelectionFieldsWithSpreads(
      selectionSet,
      type,
      schema,
      allFragments,
      scalars,
      `${indent}  `,
    );

    // If there are fragment spreads, generate intersection type
    if (spreadFragments.length > 0) {
      const spreadTypes = spreadFragments
        .map((f) => toFragmentTypeName(f))
        .join(" & ");
      if (fields) {
        return `${spreadTypes} & {\n${fields}\n${indent}}`;
      }
      return spreadTypes;
    }

    return `{\n${fields}\n${indent}}`;
  }

  return "unknown";
}

/**
 * Convert a GraphQL type to TypeScript type string
 */
function graphqlTypeToTS(
  type:
    | GraphQLType
    | { kind: string; type?: unknown; name?: { value: string } },
  scalars: Record<string, string>,
): string {
  // Handle AST types (from variable definitions)
  if ("kind" in type && typeof type.kind === "string") {
    if (type.kind === "NonNullType" && type.type) {
      return graphqlTypeToTS(
        type.type as { kind: string; type?: unknown; name?: { value: string } },
        scalars,
      );
    }
    if (type.kind === "ListType" && type.type) {
      const inner = graphqlTypeToTS(
        type.type as { kind: string; type?: unknown; name?: { value: string } },
        scalars,
      );
      return `Array<${inner}> | null`;
    }
    if (type.kind === "NamedType" && type.name?.value) {
      const name = type.name.value;
      return scalars[name] ?? name;
    }
  }

  // Handle runtime types
  if (isNonNullType(type)) {
    return graphqlTypeToTS(type.ofType, scalars);
  }
  if (isListType(type)) {
    const inner = graphqlTypeToTS(type.ofType, scalars);
    return `Array<${inner}> | null`;
  }
  if (isScalarType(type)) {
    return scalars[type.name] ?? "unknown";
  }
  if (isEnumType(type)) {
    return type.name;
  }
  if (isInputObjectType(type) || isObjectType(type)) {
    return type.name;
  }

  return "unknown";
}
