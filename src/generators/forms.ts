/**
 * TanStack Form options generator
 * Generates formOptions exports for mutations
 */

import {
  createDefaultGenContext,
  generateDefaultValuesCode,
} from "./zod/defaults";
import { toCamelCase, toPascalCase, toSchemaName } from "./zod/index";

/**
 * Information about a mutation operation for form generation
 */
export interface MutationOperation {
  /** Operation ID / name */
  operationId: string;
  /** The Zod schema variable name for the request body */
  requestSchemaName: string;
  /** The full Zod schema string for generating defaults */
  requestSchemaCode: string;
}

/**
 * Options for form options code generation
 */
export interface FormOptionsGenOptions {
  /** Import path for the schema file */
  schemaImportPath: string;
  /** All Zod schema strings (for resolving references in defaults) */
  allSchemas: string[];
}

/**
 * Result of form options generation
 */
export interface FormOptionsResult {
  /** Generated code content */
  content: string;
  /** Warnings during generation */
  warnings: string[];
}

/**
 * Generate TanStack Form options code for mutations
 */
export function generateFormOptionsCode(
  mutations: MutationOperation[],
  options: FormOptionsGenOptions,
): FormOptionsResult {
  const warnings: string[] = [];

  if (mutations.length === 0) {
    return {
      content: generateEmptyFormFile(),
      warnings: [
        "No mutations found with request bodies to generate form options for.",
      ],
    };
  }

  // Create context for default value generation
  const defaultCtx = createDefaultGenContext(options.allSchemas);

  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/* This file is auto-generated by tangen. Do not edit. */");
  lines.push("");
  lines.push('import { formOptions } from "@tanstack/react-form"');
  lines.push("");

  // Collect all schema imports
  const schemaImports = mutations.map((m) => m.requestSchemaName);
  if (schemaImports.length > 0) {
    lines.push(
      `import { ${schemaImports.join(", ")} } from "${options.schemaImportPath}"`,
    );
    lines.push("");
  }

  // Generate form options for each mutation
  for (const mutation of mutations) {
    const formOptionsName = `${toCamelCase(mutation.operationId)}FormOptions`;

    // Generate default values code
    let defaultValuesCode: string;
    try {
      defaultValuesCode = generateDefaultValuesCode(
        mutation.requestSchemaCode,
        defaultCtx,
        "    ",
      );
    } catch (e) {
      warnings.push(
        `Failed to generate default values for ${mutation.operationId}: ${e}`,
      );
      defaultValuesCode = "{}";
    }

    lines.push(`export const ${formOptionsName} = formOptions({`);
    lines.push(`  defaultValues: ${defaultValuesCode},`);
    lines.push(`  validators: {`);
    lines.push(`    onSubmitAsync: ${mutation.requestSchemaName},`);
    lines.push(`  },`);
    lines.push(`})`);
    lines.push("");
  }

  return {
    content: lines.join("\n"),
    warnings,
  };
}

/**
 * Generate an empty form file when no mutations are found
 */
function generateEmptyFormFile(): string {
  return `/* eslint-disable */
/* This file is auto-generated by tangen. Do not edit. */

// No mutations with request bodies found to generate form options for.
// Add mutations to your schema/documents to generate form options.
`;
}

/**
 * Filter OpenAPI operations to only mutations (POST, PUT, PATCH) with request bodies
 */
export function filterOpenAPIMutations(
  operations: Array<{
    operationId: string;
    method: string;
    requestBody?: unknown;
  }>,
): string[] {
  const mutationMethods = new Set(["post", "put", "patch"]);

  return operations
    .filter((op) => mutationMethods.has(op.method) && op.requestBody)
    .map((op) => op.operationId);
}

/**
 * Filter GraphQL operations to only mutations
 */
export function filterGraphQLMutations(
  operations: Array<{
    name: string;
    operation: "query" | "mutation" | "subscription";
  }>,
): string[] {
  return operations
    .filter((op) => op.operation === "mutation")
    .map((op) => op.name);
}

/**
 * Get the request schema name for an OpenAPI operation
 */
export function getOpenAPIRequestSchemaName(operationId: string): string {
  return toSchemaName(`${toPascalCase(operationId)}Request`);
}

/**
 * Get the request schema name for a GraphQL mutation
 * GraphQL mutations use input types from variables, so we need to look at the variable definitions
 */
export function getGraphQLInputSchemaName(inputTypeName: string): string {
  return toSchemaName(inputTypeName);
}
