import { resolve } from "node:path";

import { describe, expect, it } from "vitest";

import { loadDocuments } from "../core/documents";
import { testSchema } from "../test/fixtures/schema";
import { generateTypes } from "./types";

const fixturesDir = resolve(__dirname, "../test/fixtures/graphql");

describe("generateTypes", () => {
  it("generates types file with eslint-disable comment", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("/* eslint-disable */");
  });

  it("generates types file with auto-generated comment", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("auto-generated by tangen");
  });

  it("generates enum types from schema", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("export enum UserRole");
    expect(result).toContain("ADMIN");
    expect(result).toContain("USER");
    expect(result).toContain("GUEST");
  });

  it("generates input types from schema", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("export type CreateUserInput");
    expect(result).toContain("export type UpdateUserInput");
  });

  it("generates fragment types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("export type UserFieldsFragment");
  });

  it("generates query return types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("export type GetUserQuery");
    expect(result).toContain("export type ListUsersQuery");
  });

  it("generates query variables types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("export type GetUserQueryVariables");
    expect(result).toContain("export type ListUsersQueryVariables");
  });

  it("generates mutation return types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("export type CreateUserMutation");
    expect(result).toContain("export type UpdateUserMutation");
    expect(result).toContain("export type DeleteUserMutation");
  });

  it("generates mutation variables types", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toContain("export type CreateUserMutationVariables");
    expect(result).toContain("export type UpdateUserMutationVariables");
    expect(result).toContain("export type DeleteUserMutationVariables");
  });

  it("uses custom scalar mappings", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
      scalars: { DateTime: "Date" },
    });

    expect(result).toContain("Date");
  });

  it("generates empty variables type for operations without variables", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    // DeleteUser has only one required variable, so it should have a variables type
    expect(result).toContain("DeleteUserMutationVariables");
  });

  it("handles nullable fields correctly", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    // avatarUrl is nullable in the schema
    expect(result).toContain("avatarUrl");
  });

  it("matches snapshot for user operations", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toMatchSnapshot();
  });

  it("matches snapshot for post operations with nested fragments", async () => {
    const documents = await loadDocuments([
      `${fixturesDir}/user.graphql`,
      `${fixturesDir}/post.graphql`,
    ]);
    const result = generateTypes({
      schema: testSchema,
      documents,
    });

    expect(result).toMatchSnapshot();
  });

  it("matches snapshot with custom scalars", async () => {
    const documents = await loadDocuments(`${fixturesDir}/user.graphql`);
    const result = generateTypes({
      schema: testSchema,
      documents,
      scalars: {
        DateTime: "Date",
        JSON: "Record<string, unknown>",
      },
    });

    expect(result).toMatchSnapshot();
  });

  describe("alias handling", () => {
    it("generates correct types for aliased fields", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetMultipleUsers should have firstUser and secondUser, not user
      expect(result).toContain("firstUser:");
      expect(result).toContain("secondUser:");
    });

    it("generates aliased field names in inline selections", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetUsersWithAliases should use aliased names
      expect(result).toContain("allUsers:");
      expect(result).toContain("userId:");
      expect(result).toContain("userName:");
      expect(result).toContain("userEmail:");
    });

    it("supports aliased __typename", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetUserWithTypename should have type: instead of __typename:
      expect(result).toContain('type: "User"');
    });

    it("handles mixed aliased and non-aliased fields", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      // GetMixedFields should have both aliased and non-aliased fields
      expect(result).toContain("id:");
      expect(result).toContain("displayName:");
      expect(result).toContain("email:");
      expect(result).toContain("avatar:");
    });

    it("matches snapshot for aliased operations", async () => {
      const documents = await loadDocuments(`${fixturesDir}/alias.graphql`);
      const result = generateTypes({
        schema: testSchema,
        documents,
      });

      expect(result).toMatchSnapshot();
    });
  });
});
