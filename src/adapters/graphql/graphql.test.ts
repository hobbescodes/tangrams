import { join } from "node:path";

import { Kind, OperationTypeNode, buildSchema } from "graphql";
import { describe, expect, it } from "vitest";

import { graphqlAdapter } from "./index";

import type { GraphQLSourceConfig } from "@/core/config";
import type { GraphQLAdapterSchema } from "../types";

const fixturesDir = join(__dirname, "../../test/fixtures/graphql");

// Test schema for unit tests (doesn't require network)
const testSchemaSDL = `
  type Query {
    user(id: ID!): User
    users: [User!]!
  }
  
  type Mutation {
    createUser(name: String!): User!
  }
  
  type User {
    id: ID!
    name: String!
    email: String!
  }
`;

const testSchema = buildSchema(testSchemaSDL);

describe("GraphQL Adapter", () => {
  const testConfig: GraphQLSourceConfig = {
    name: "test-api",
    type: "graphql",
    schema: { url: "http://localhost:4000/graphql" },
    documents: join(fixturesDir, "*.graphql"),
  };

  describe("adapter properties", () => {
    it("has type property set to graphql", () => {
      expect(graphqlAdapter.type).toBe("graphql");
    });
  });

  describe("generateClient", () => {
    it("generates a GraphQL client file", () => {
      const schema: GraphQLAdapterSchema = {
        schema: testSchema,
        documents: { operations: [], fragments: [] },
      };

      const result = graphqlAdapter.generateClient(schema, testConfig, {
        queryConfig: {
          sources: [testConfig],
          files: {
            client: "client.ts",
            types: "types.ts",
            operations: "operations.ts",
          },
        },
        outputDir: "./generated",
      });

      expect(result.filename).toBe("client.ts");
      expect(result.content).toContain("GraphQLClient");
      expect(result.content).toContain("graphql-request");
      expect(result.content).toContain("http://localhost:4000/graphql");
      expect(result.content).toContain("getClient");
    });

    it("uses the schema URL from config", () => {
      const customConfig: GraphQLSourceConfig = {
        ...testConfig,
        schema: { url: "https://api.example.com/graphql" },
      };

      const schema: GraphQLAdapterSchema = {
        schema: testSchema,
        documents: { operations: [], fragments: [] },
      };

      const result = graphqlAdapter.generateClient(schema, customConfig, {
        queryConfig: {
          sources: [customConfig],
          files: {
            client: "client.ts",
            types: "types.ts",
            operations: "operations.ts",
          },
        },
        outputDir: "./generated",
      });

      expect(result.content).toContain("https://api.example.com/graphql");
    });
  });

  describe("generateTypes", () => {
    it("generates TypeScript types from schema and documents", () => {
      const schema: GraphQLAdapterSchema = {
        schema: testSchema,
        documents: { operations: [], fragments: [] },
      };

      const result = graphqlAdapter.generateTypes(schema, testConfig, {});

      expect(result.filename).toBe("types.ts");
      // Even with no operations, the file should have the auto-generated header
      expect(result.content).toContain("eslint-disable");
      expect(result.content).toContain("auto-generated by tangen");
    });

    it("applies custom scalar mappings", () => {
      const configWithScalars: GraphQLSourceConfig = {
        ...testConfig,
        scalars: { DateTime: "Date" },
      };

      const schemaWithDateTime = buildSchema(`
        scalar DateTime
        type Query {
          now: DateTime!
        }
      `);

      const schema: GraphQLAdapterSchema = {
        schema: schemaWithDateTime,
        documents: { operations: [], fragments: [] },
      };

      const result = graphqlAdapter.generateTypes(schema, configWithScalars, {
        scalars: configWithScalars.scalars,
      });

      expect(result.filename).toBe("types.ts");
    });
  });

  describe("generateOperations", () => {
    it("generates TanStack Query operation helpers", () => {
      const schema: GraphQLAdapterSchema = {
        schema: testSchema,
        documents: {
          operations: [
            {
              name: "GetUser",
              operation: "query",
              document: "query GetUser($id: ID!) { user(id: $id) { id name } }",
              node: {
                kind: Kind.OPERATION_DEFINITION,
                operation: OperationTypeNode.QUERY,
                name: { kind: Kind.NAME, value: "GetUser" },
                variableDefinitions: [
                  {
                    kind: Kind.VARIABLE_DEFINITION,
                    variable: {
                      kind: Kind.VARIABLE,
                      name: { kind: Kind.NAME, value: "id" },
                    },
                    type: {
                      kind: Kind.NON_NULL_TYPE,
                      type: {
                        kind: Kind.NAMED_TYPE,
                        name: { kind: Kind.NAME, value: "ID" },
                      },
                    },
                  },
                ],
                selectionSet: { kind: Kind.SELECTION_SET, selections: [] },
              },
            },
          ],
          fragments: [],
        },
      };

      const result = graphqlAdapter.generateOperations(schema, testConfig, {
        clientImportPath: "./client",
        typesImportPath: "./types",
        sourceName: "test",
      });

      expect(result.filename).toBe("operations.ts");
      expect(result.content).toContain("@tanstack/react-query");
      expect(result.content).toContain("queryOptions");
      expect(result.content).toContain("getUserQueryOptions");
    });

    it("includes source name in query keys when multi-source", () => {
      const schema: GraphQLAdapterSchema = {
        schema: testSchema,
        documents: {
          operations: [
            {
              name: "GetUsers",
              operation: "query",
              document: "query GetUsers { users { id } }",
              node: {
                kind: Kind.OPERATION_DEFINITION,
                operation: OperationTypeNode.QUERY,
                name: { kind: Kind.NAME, value: "GetUsers" },
                selectionSet: { kind: Kind.SELECTION_SET, selections: [] },
              },
            },
          ],
          fragments: [],
        },
      };

      const result = graphqlAdapter.generateOperations(schema, testConfig, {
        clientImportPath: "./client",
        typesImportPath: "./types",
        sourceName: "test",
      });

      // The query key should include the operation name
      expect(result.content).toContain("GetUsers");
    });
  });
});
